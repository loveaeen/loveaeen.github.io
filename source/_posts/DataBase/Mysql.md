---
title: Mysql
date: 2022-03-28 14:43:12
categories: DataBase
excerpt: Mysql是目前主流的数据库之一, 跟Oracle相比, 他更轻量, 并且互联网上关于对他的插件扩展也更多
tags: 
typora-root-url: ../../
---

Mysql是目前主流的数据库之一, 跟**Oracle**相比, 他更轻量, 并且互联网上关于对他的插件扩展也更多. 他的索引页, 数据页, 缓存页, 都是我们需要掌握并了解的. 当你掌握了这些知识以后, 你对Mysql性能调优会更有把握, 并且与人交谈时, 会显示你的资本积累无比深厚, 自然显得技术高强些. 当然, 光看文字也是不行的, 你也需要搭配一些图例来让脑海中的知识更加清晰化。

首先我们如果需要了解Mysql, 首当其冲的就是**Buffer pool**概念. 我们知道Mysql是将数据插入至磁盘的, 但是我们不能一直和磁盘打交道. 这样会让我们的读/写速度都很慢. 所以Mysql会将一些数据放入到内存中, 优先和内存数据交互

## Buffer pool

缓冲池默认是 **128Mb** , 存储的全都是**数据页**[^1]的信息. 数据页会存储在磁盘和缓存中. 但是如果存储在缓存的话, 我们一般称之为**缓存页**. 既然学习到数据页的概念, 那么我们也要简单看一下数据页长什么样子. 除了数据页本身, 缓冲池里面还会记录每一个数据页的**描述信息**[^2]

缓冲池初始化时并不是空的, 它会默认用空缓存页填充自己. 类似于占位符一样的形式. 所以需要使用free链表来判断哪些缓存页是可以存入的.

那么如果某个缓存页被用户读取了之后, 用户修改了这个缓存页怎么办, 那不就跟磁盘数据不一致了吗? 于是乎, flush链表出现了.

缓存页可以让我们加速数据处理, 但缓冲池的空间是固定的, 以前旧的不常用的缓存页怎么删除, 腾出空间给新的缓存页呢? LRU链表

缓冲池是用户主要打交道的组件, 那么磁盘数据是如何放到缓冲池里面的呢? 数据页何时被缓存

既然我们有了这么多的链表结构, 那么会不会定时清理一些不用的缓存页呢? 定期清理缓存链表

### Free链表

因为缓冲池里面缓存页都是占位形式, 所以我们不知道哪些缓存页是空闲状态. 于是Mysql增加了双向链表来判断. 首先当数据库初始化的时候, 缓存页全部都是空的, 那么这些缓存页的描述信息都会存入到链表里面来. 只要有缓存页需要被存入, 那么就会把链表里对应的描述信息删除.

### Flush链表

当用户修改了缓存页的信息时, 磁盘数据页并没有被刷新, 这时候就被称之为[脏页] 所以Mysql规定了, 如果当用户修改了缓存页信息, 则会把缓存页的描述信息块存放到flush链表里来. 后续是要被flush到磁盘里的

### LRU链表

为了在有限的空间内, 尽量让热点数据存储进来, 于是出现了LRU链表. 但是Mysql的LRU链表并不是我们认为的那种, 他是两部分链表, 分为[**热数据** , **冷数据**] [[LRU链表图]]. 当一个数据页被存入缓冲池中时, LRU链表就会将该条缓存页的描述信息加载到**冷数据链表**的头部.

>  那么什么时候**冷数据**会转移到**热数据**中呢?

Mysql定义了一个配置`innodb_old_blocks_time` 默认值是1000 毫秒. 意思就是当一个数据页被加载到缓存页的1秒后, 你又一次对他进行了访问. 那么这条数据页就会被缓存到**热数据**链表的头部.

如果你访问的是**热数据**链表的数据, 那么根据规则, 如果你访问的区域是后3/4的缓存页, 那么Mysql会将该缓存页移动至链表头部, 但是如果访问的是前1/4区域的话. 这些数据页的位置是不动的

### 数据页缓存时机

当我们执行CRUD的时候, 首先会去缓冲池查数据所在的数据页是否被缓存了. 如果已经有了缓存, 那么我们直接就将缓存拿出来用. 如果数据页没被缓存, 那么我们就去free链表找到一个空闲的缓存页. 然后从磁盘上读取该数据页. 写入描述数据, 并从free链表中删删除这个描述数据块.

但是我们怎么能快速找到某个数据页是否被缓存了呢? 所以其实在数据库中, 维护了一个哈希表结构的数据. 里面是**表空间号+数据页号**为key, **缓存页地址**为value的这么一个表. 当用户需要使用某个数据页的时候. 通过该表进行查找, 就能快速定位到该数据页是否被缓存了.

### 定期清理缓存

1. 定时将flush链表的缓存页都刷入到磁盘中, 解决[**脏页**]问题

2. 定时将LRU链表中**冷数据**尾部的缓存页清除, 并增加free链表

## TableSpace & DataArea

当了解完了内存知识以后, 就该将目标转向磁盘了. 平时, 我们会在Mysql中创建一个表, 表本身有一个表空间的概念. 在磁盘中命名为**表名.ibd**文件.

而数据是存储在数据页中的, 但是数据页默认是16kb而已, 一个表空间有太多的16kb了, 特别不方便管理, 所以Mysql引入了**数据区**的概念.

一个数据区对应着连续的64个数据页, 每个数据页是16kb, 所以一个数据区正好是1mb. 然后256个数据区被称为**组**

在每组数据区的第一个数据区的前三页, 里面存放的是**描述性数据**

## RedoLog

RedoLog文件我们应该都有听说过. 其实就是事务记录文件, 但是他不是在事务提交时才会记录, 而是在数据修改时就会记录, 记录为 **Prepare** 状态，当用户提交时，更新状态为 **Commit**. Mysql默认会创建2个RedoLog文件, 事务记录会循环交替的在两个文件内写入覆盖. 如果想深入研究的话, 可以看一看RedoLog文件到底存储了什么样的修改信息.

虽然RedoLog是磁盘顺序写, 这样的写入速度很快, 但是还不够快! 我们依然要增加内存机制来提高它的写入速度!

- **RedoLog buffer**会在Mysql启动时, 创建出来. **默认[16mb]** 类似于**Buffer pool** . 他会申请一片连续的内存空间, 里面划分出N多个空的RedoLog block[^3]

那么内存中的RedoLog什么时候刷入磁盘呢?

- 如果写入的RedoLog buffer日志已经占据总容量的一半了. 也就是大约8mb, 于是就会将日志刷入磁盘.
- 事务提交的时候, 会将他对应的RedoLog所在的RedoLog block刷入到磁盘中[^4]
- 定时线程每隔一秒会将block数据刷入磁盘
- Mysql关闭时, 会将block数据刷入磁盘

## UndoLog

中文意 [回滚日志] , 看名字就知道是专门用于事务提交失败或Mysql突然宕机时用于数据回滚的. 它记录的内容非常简单, 比如你insert了一条数据. 那么在日志里, 就会记录一条delete id的回滚数据. 所以当你执行事务期间, 你的DML语句不止会写入RedoLog, 也会写入UndoLog

而UndoLog还有其他的作用, 就是Mysql的最重要的隔离级别控制，这块内容容我稍后再说。

## BinLog

BinLog不是默认开启的, 需要人为手动开启. 它记录了对Mysql执行**提交后**的所有操作. 但是相比RedoLog而言, 他记录的信息没有那么全面, 仅仅记录的对应的sql语句. 但是不要觉得只记录sql有什么不好, 正因为有BinLog我们才可以通过**Canal**来对数据库做监控与数据sql转发.

但是BinLog有一点不友好, 他的文件是不停增多的. 并不是循环覆盖的原则, 替我们省磁盘空间. 我们还需要设置Mysql的BinLog过期时间, 让Mysql帮我们删除旧文件

## MVCC

简单的来说, 在Mysql中的每一行数据都是有三个隐藏字段的 `rowid` ` trx_id`  `roll_pointer` `rowid`我们就不多说了, `trx_id`就是这条数据最近的一次事务id. `roll_pointer`则是指向了这次事务之前的UndoLog 接下来我们举个例子

### Example

假如我们开启了事务A, 在这个事务里, 我们插入了一条数据, 这次事务的id为50, 此时版本链的隐藏字段为下图所示.

![img](image/Mysql/imgs%252Fapp%252FRoamWeb%252Fw6_LOfove7.jpeg)

接着事务B开启了, 他修改了这一条数据. 事务B的id为58, 那么版本链就产生了

![img](/image/Mysql/imgs%252Fapp%252FRoamWeb%252FtfTQCQAYPl.jpeg)

接着又来了一个事务C, 他也耐不住寂寞, 也来改了一下这条数据

![img](/image/Mysql/imgs%252Fapp%252FRoamWeb%252FOJDLEbzw8d.jpeg)

以上就是多版本控制的简述, 其实不难理解. 但是多版本控制只是一个辅助功能, 它主要是为了与**ReadView读视图**搭配, 用于管理隔离级别

## ReadView

ReadView是Mysql对于控制隔离级别的一个重要概念, 简单来说, 就是你在执行一个事务的时候, 会生成一个ReadView. 里面比较关键的有四个部分

- `m_ids` : 此时有哪些事务在Mysql执行还没有提交的
- `min_trx_id` : 就是m_ids里面最小的值
- `max_trx_id` : 就是Mysql下一个要生成的事务id, 就是最大的事务id
- `creator_trx_id` : 当前的事务id

这四个部分在简单非并发查询时并没有太大的作用，他们存在的意义是解决并发查询时出现的隔离级别问题。

### Example

> 并发事务查询, 大致分为下列三种情况, 我们给出一个前提条件. 查询的事务A(id=45) | 并发更新的事务B(id=59) | 操作的数据(trx_id = 32)

1. 数据的`trx_id`小于当前执行事务id

   当事务A查询数据的时候, 他会判断一下, 看一下这条数据的trx_id是否小于ReadView中的min_trx_id. 判断后发现是小于的. 那么直接就可以查询这条数据的信息, 不用去找版本链了

2. 数据的`trx_id`大于当前执行事务id

   在上面的事务A查询完后, 事务B修改了这条数据, 数据的`trx_id`变成了59. 然后事务A又进行了一次查询. 他会发现数据的trx_id是大于min_trx_id, 同时小于max_trx_id. 这时候他就明白了, 有并发事务修改了这条数据. 然后看一下m_ids是否存在这条数据的trx_id, 果然存在! 那么我们就不能查询这条数据的当前信息了. 只能通过版本链回滚查询到小于等于自己事务id的数据信息

3. 数据的`trx_id`等于当前执行事务id

   这条没啥好说的, 数据的事务id都跟自己的事务id一样了, 还要判断啥呢, 肯定是自己改的啊. 直接查!

### RC

当设置了RC隔离级别时, 每一次的查询都会生成一个ReadView. 如果数据的`trx_id`在m_ids中的话, 就不允许被读取, 必须去版本链找≤自己事务id的数据出来. 如果反之的话, 那就直接读取该条数据.

### RR

与RC不一样的是, 一个事务只会开启一次ReadView. 所以这就会导致, 事务内后续的查询时, 其他的并发事务已经提交了, 但是ReadView中的m_ids还是保存了这些并发事务信息, 于是就只能去找版本链的数据.

## Data Page

我们知道, 一行一行的数据是存储在**数据页**中的 ,索引也是存储在数据页中. 每一个数据页都会有他自己的页目录. 我们也知道, InnoDB 引擎默认是必须存在主键的, 这也就保证了每张表都会存在主键索引, 既然有了索引, 那么所有的数据都需要按照主键顺序排列, 如果主键是中英文混杂的话, 我们还需要对他做转换, 保证可以比较大小. 所以中英文主键的查询速度是会比纯数字的速度较慢一些.

那么如果是按照顺序的话, 我先增加了一条id为10的数据, 我又增加了一条id为2的数据. 实际上会怎么存储呢? 于是Mysql页分裂[^5]出现了, 他能帮我们解决主键顺序问题.

既然我们知道了数据页的一些简单概念, 那么Mysql是如何查询的呢?

- 单数据页查询

  假如我们查询的一张表中, 压根没多少数据, 也就一个数据页的大小. 那么Mysql就会直接到数据页的页目录中根据主键进行二分查找. 快速定位到主键的槽位, 然后遍历槽位的每一行数据, 找到主键对应的数据为止. 因为一个槽位可能存储了一组数据, 所以需要在槽位里遍历查找.

- 多数据页查询

  如果是多数据页的话，我们需要一个新知识来帮我们快速定位到指定的数据页中，然后才能用单数据页的方式来查询，稍后我再来说索引页相关内容。

### Page directory

[深入研究Mysql页结构](https://blog.csdn.net/jy02268879/article/details/105652206)

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？

设计InnoDB的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

- 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
- 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录
- 将每个组的最后一条记录的地址偏移量单独提取出来，用作查找。

注意：这个页目录是为主键服务的。

![img](/image/Mysql/format,png.png)

对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1-8 条之间，剩下的分组中记录的条数范围只能在是 4-8 条之间。

分组是按照下边的步骤进行：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

我们再添加12条记录看看效果：

![img](/image/Mysql/format,png-20220328150555793.png)

因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的n_owned和next_record属性。

因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

- 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最大的那条记录。
- 通过记录的next_record属性遍历该槽所在的组中的各个记录。

比方说我们想找主键值为6的记录，过程是这样的：

计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 > 6，所以设置high=2，low保持不变。

重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 < 6，所以设置low=1，high保持不变。

因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。

我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录

注意：若查到数据在槽2的分组中，由于槽2是指向最后一个记录，所以需要向上找一个槽位，定位到上一个槽位最后一行，然后再向下找。

## Index Page

索引页也又称**[主键目录]. **简单来说就是如果一张表数据很大的话, 那么自然会有很多的数据页出现. 因为你的索引也是存储在里面的, 所以会出现**索引页**. 而索引页中存储的就是多个数据页中最小的主键id与数据页号.

<font color='red'>B+树中的非叶子节点存储的是索引页，索引页里面存储的是下方非叶子节点的索引页最小ID，在最底层的非叶子节点的索引页里面存储的是数据页的最小主键id，而叶子节点存储的就是数据页信息。</font>

![img](/image/Mysql/iShot2022-02-17%2015.14.10.png)

但是如果数据真的比较庞大, 索引页出来很多呢? 我们怎么快速定位到我们想要的索引页? 于是一个全新的概念产生了索引B+树

对于 InnoDB 来说，所有的数据都是以键值对的方式存储的，主键索引和辅助索引在存储数据时会将 id 和 index 作为键，将所有列和 id 作为键对应的值. 在 B+ 树中, 所有的非叶子节点都是存储的索引值, 只有叶子节点才会存储数据.

- 但是因为辅助索引存储的是 id 的原因, 所以需要二次回表查询.

一个 B+ 树构建出来以后, 我们以主键索引为例. 当我们查询数据时, 首先就会从 B+ 数的顶层开始二分查找, 一直找到我们需要的叶子节点, 叶子节点存储的不是实际的数据, 而是**数据页**. 所以我们需要再通过数据页知识来结束查询。

### Union Index

在这里我们单独将「联合索引」的结构拿出来记录，网络上对于该存储结构有两种不同的观点论述。

其一是索引树的非叶子节点上存储的是最左侧列的值，通过该值进行后续的依次查找。

<font color='red'>其二是索引树的非叶子节点上存储的是所有列的值，然后根据各个值进行依次查找。</font>

经过查找与阅读书籍，我更倾向于多列组合存储的方式。其实不管如何存储，本质上查找数据都是需要一项项的查找，这也就出现了我们熟知的「最左匹配」问题。

我们可以将联合索引想像成电话簿，通过最左匹配的「姓」，我们可以很快速的找到后续的「中间字+末尾字」。但是如果没有最左项，我们肯定只能扫描全部项进行全表查询。

若我们的条件只有「姓+末尾字」，缺少了「中间字」，那么我们根据原则，只能用到复合索引中的「姓」索引，无法继续采用后续的索引。

## Master & Slave

因为以我目前接触的项目体重, 使用到 Mysql 集群的可能性微乎其微, 所以在这里只是简单记录一下. 当我们创建了集群时, Mysql 集群并不会保证高可用. 这需要我们自己通过第三方插件实现. 比如**MHA**. 他会部署一台 Manager 节点, 然后在每一台 Mysql 服务器上部署 Node 节点. 如果某个 Master 节点宕机, 那么他就会将 Slave 提升上去.

但是高可用也有个缺点. 如果你的某个服务器变成了主节点, 那么 java 项目如果动态更改主库地址呢? 需要研究一下这个问题

### Mode

**普通日志复制(5.6 before)：**MySQL最早支持的复制技术，BUG相对较少，对SQL查询没什么限制，故障处理比较弱容易，但是在主节点挂掉，由从节点选举后可能会造成信息丢失问题

**GTID全局事务ID复制(5.6 after)：**很方便的支持高可用，但是不支持非事务引擎，不支持 `sql_slave_skip_counter` (一般用这个来跳过基于binlog主从复制出现的问题)。也不支持`create table … select` 以及 `create temporary table`

### Principle

主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的.

这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是**有延时**的. 所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到

- **同步复制：**最没用的复制方式

  指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。

- **异步复制(默认)：**提供了主从方案，降低了单节点运行数据库的风险

  主库执行完事务后立即响应客户端，不理会从库是否接收到自己的信息。这个方式可靠性很差，容易丢失数据，但是响应速度很快。如果主服务器崩溃，它已提交的事务可能不会传输到任何从服务器。因此，在这种情况下，从主服务器故障转移到从服务器可能会导致故障转移到缺少与主服务器相关的事务的服务器。异步复制提供了较低的写入延迟，因为写入在写入从属之前由主机本地确认。它非常适合读取扩展，因为添加更多副本不会影响复制延迟。异步复制的良好用例包括为读取扩展部署只读副本、用于灾难恢复和分析/报告的实时备份副本。

- **增强半同步复制(优化)：**异步主从复制的加强，解决了数据丢失的风险，但是依然存在网络延迟，切换麻烦的问题(例如10个节点，1主9从，主节点宕机，当把一个从节点提升为主节点后，其它节点需要手动修改master)

  也叫 `semi-sync` 复制，指的就是主库写入 binlog 日志之后，就会将**强制**此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到**至少一个从库**的 ack 之后才会认为写操作完成了。要启用半同步复制，需要额外的插件安装步骤，并且必须在指定的 MySQL master 和 slave 上启用。

- **组复制(MGR)：**拥有了自动故障转移failover的能力，当主节点发生故障(单主模式才需考虑)时，组内部会自动选择主节点。

  是一种主从复制的**高可用**技术，分为**单主模式**和**多主模式**。与上述复制不同的是，所有读写事务仅在获得组批准后才提交。

### Parallel

主备延迟的主要原因在于，master A 上产生 binlog 的速度大于slave B 处理 binlog 的速度。数据的积压就在于 `sql_thread` 处理的速度. 为了要减少延迟, 我找到了以下几种方式

1. 并行复制

   Mysql 5.6版本只支持 schema 级别的并行复制. 也就是主库有两个 schema 分别是 jiedu , wlry. 从库也是这两个, 那么进行数据同步时, 最小级别也是 schema 级别. 不会提升单库多表的速度

   Mysql 5.7 版本支持了**基于组提交的并行复制**. 说起来比较复杂, 就是跟全局事务 ID 有关. 但是这种复制方式支持到了表级别.更适合单库多表!

   Mysql 8.0 版本支持 WriteSet 复制方式.

2. 主从库拆分. 将写压力进行分散. 提高从库的执行速度

3. 通过 ShardingSphere 来控制插入数据之后, 查询主库数据, 而不走从库查询. 直接不让用户感知到任何延迟.

### High Availability

#### MHA

**MHA**由两部分组成：**MHA Manager**（管理节点）和**MHA Node**（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上，生产环境中多数单独部署。 MHA Node运行在每个MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将判断最新数据的slave提升为新的master，并将所有其他的slave重新指向新的master。但是需要注意MHA是不会管Slave是否宕机的，如果Slave宕机，应用程序依然会错误的向其发起请求。

在一个Master node CRASH时，MHA 负责Master-Slave Auto-failover，默认情况下，MySQL复制是异步的。MHA试图从宕机的主服务器上保存二进制日志，通过ssh补齐日志，所以需要root用户，同时负载启停VIP. 如果主服务器崩溃，则它已提交的事务可能尚未传输到任何从服务器。因此，在这种情况下从主服务器到从服务器的故障转移可能导致事务丢失，所以通常还需要使用半同步替代异步，与半同步复制相结合，可以降低由于主硬件故障导致数据丢失的风险。

[简单搭建请点击这里🔗](https://juejin.cn/post/6844904099075325960#heading-10)

生产环境中最常用的还是采用MHA方案，并且网络上有使用master_ip_failover_script脚本创建Zookeeper节点的方式，再由Java监听后让ShardingSphere动态切换主库的高可用方案，但是没找到具体实现，而且这套架构无法实现检测从库是否正常，所以我们可以再引入HAProxy组件，对所有slave节点进行负载均衡。

#### MGR

MGR是Mysql内置的高可用组件，需要Mysql开启GTID方案才能使用。这个方式是Oracle公司推荐的，并且可以与ShardingSphere相结合实现动态转移 (目前只支持单主模式)。

#### HAProxy

HAProxy 代表 High Availability Proxy，是一款出色的基于软件的 TCP/HTTP 负载均衡器。 它在一组服务器之间分配工作负载，以最大限度地提高性能并优化资源使用。 HAProxy 使用复杂且可定制的健康检查方法构建，允许在单个运行实例中实现多个服务的负载平衡。

HAProxy通过配置文件中可以配置Mysql、Tcp、Http三种检测方式，若某个节点异常，HAProxy将忽略该节点的负载均衡。

但是HAProxy本身是单点的，我们为了解决单点故障的问题，可以加入Keepalived等组件解决这个问题。

[HAProxy的简易单主多从实现](https://blog.csdn.net/qq_34556414/article/details/105143584)

#### Mycat

看了一下Mycat官方文档，对于MGR、MHA等都有非常好的兼容模式，可以实现动态数据源更改，但是使用似乎不太广泛。

---

[^1]: Mysql的数据虽然是一行一行的, 但是这些数据会最终存储在数据页里面. 当用户查询/更新某一条数据时, 会将该数据的当前页以及相邻页全部放入到缓冲池里面.
[^2]: 描述信息是数据页所属的表空间, 数据页的编号, 在缓冲池中的地址以及一些额外信息. 描述文件大约占据缓冲池的5%容量. 比如你创建的是128Mb的缓冲池. 那么加上描述信息, 实际上在130+左右的大小. 
[^3]: Mysql的数据存储在了数据页里面, 同样的, RedoLog日志信息也存储在了Block中. block大小为512byte. 分为三个部分head body trailer
[^4]: 因为存在OS cache的情况, 所以实际上并不是直接刷入到磁盘中, 而是从内存进入到OS cache里. 之后由操作系统进行文件写入. Mysql有参数可以直接将日志刷入磁盘, 不走OS cache
[^5]: 页分裂的概念是当存在后一个数据页的部分数据主键比前一个数据页中的主键小时, Mysql会自动帮你调整主键大小, 他会保证这两个数据页中的主键值一定是按照从小到大的顺序排列