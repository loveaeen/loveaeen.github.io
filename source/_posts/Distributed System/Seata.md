---
title: Seata
date: 2022-03-28 16:10:12
excerpt: Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。
categories: Distributed System
tags: 
typora-root-url: ../../
---

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务. Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案

**Seata 实现分布式事务，设计了一个关键角色 UNDO_LOG （回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在 UNDO_LOG 表中，以便业务异常能随时回滚。**

## Component

Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；

Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；

Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。

**事务开启过程**

- TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 `XID`；

- `XID` 在微服务调用链路的上下文中传播；

- RM 向 TC 注册分支事务，将其纳入 `XID` 对应全局事务的管辖；

- TM 向 TC 发起针对 `XID` 的全局提交或回滚决议；

- TC 调度 `XID` 下管辖的全部分支事务完成提交或回滚请求。

## [AT模式](https://seata.io/zh-cn/docs/dev/mode/at-mode.html)

AT模式是一种无侵入的, 基于 2PC 的分布式事务解决方案，但他并不是完美的，为了解决事务的补偿与全局事务一致性的问题，它加入了before image与after image，并会插入undo log表中用于事务回滚，而且还有少不了的RPC同步通信。组件的额外加入必然增加了不少的开销，想一想每一个sql的执行都会有如此多的额外开销，项目的分布式事务性能必然会大幅度降低。业内也有一种思路，通过数据库binlog还原镜像前后的SQL，省去了undo log生成记录的同步，降低了性能损失，同时零业务入侵，个人觉得是更好的方法。

除开性能方面，AT模式在「全局事务」与「本地事务」之间会产生脏写和脏读问题，为此，我们需要使用`@GlobalLock`的方式，让「本地事务」也去竞争全局锁。但是该方式也牺牲了不少的性能。

但是我们不能否认AT模式是最常见也是相对优异的方案，阿里为了改善及解决AT模式的弊端问题，优化了二阶段时全局锁的持有，并让二阶段提交/回滚采用了异步进行的方式。而且在保证一致性的方面，使用了更为高性能的Redis来解决，虽然这可能会因为Redis的非事务支持导致一致性的降低，但凡事没有完美，不是吗？

**一阶段**：Seata 会拦截 "业务 SQL" ，首先解析 SQL 语义，找到 "业务 SQL" 要更新的业务数据，在业务数据被更新前，将其保存成 "before image"，然后执行 "业务 SQL" 更新业务数据，在业务数据更新之后，再将其保存成 "after image" ，提交前申请全局锁，再将业务数据的更新和前面步骤中生成的 UNDO LOG 一并进行本地提交。然后释放本地锁。

一阶段提交后，若有其他本地非分布式事务操作该条数据，则会发生脏写/脏读问题。

![img](/image/Seata/v2-c2df76b462cd22fcc1b1435113e82e49_1440w.jpg)

**二阶段提交**: 因为“业务 SQL”在一阶段已经提交至数据库, 所以 Seata 框架只需异步将一阶段保存的快照数据和行锁删掉，完成数据清理并释放全局锁。

![img](/image/Seata/v2-75048a7c0f655654032213658742b7d5_1440w.jpg)

**二阶段回滚**：Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用 "before image" 还原业务数据. 但在还原前要首先要校验脏写, 对比 "数据库当前业务数据" 和 "after image"，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。

二阶段回滚时，我们需要注意，此时该该分布式事务依然持有全局锁，但是缺少了本地锁，所以需要申请。假如在二阶段回滚前，有其他本地事务操作了该数据，则会发生脏写/脏读问题。

![img](/image/Seata/v2-12a2fb645ded74b2ace2728d052a7bff_1440w.jpg)

## TCC

关于原理我们在**[分布式事务]**一文中已经做过解答。在此类目下，我们是对于Seata下的TCC模式来做讨论。

在Seata中，不管是任何模式，我们都无法绕开TC，TM，RM三大组件。在AT模式中，我们详解了全局锁在其中充当的隔离性作用，而在TCC模式中，完全不需要全局锁的存在，而且性能相比AT模式更为优异。那我们如何保证数据的隔离性呢？核心就在于TCC接口的设计，用户在接入TCC模式时，大部分工作都集中如何实现TCC服务上。相对于普通的事务操作而言，在TCC的认知上我们需要懂得预留资源的概念。在Try接口中，我们需要对资源进行冻结保留。并在Confirm/Cancel接口对该冻结资源做对应处理。Try接口的操作，其实就是预留资源的操作，我们在二阶段做的提交/回滚操作，都是处理该资源。如果出现并发问题，这样每一个TCC模型都只操作属于自己的预留资源。

关于TCC模式，我们也不免的需要了解空回滚、防悬挂、幂等性的三个难题。归功于今日互联网的技术分享，我们可以很轻松的解决这三类难题，其中最普遍的做法就是增加一张本地事务控制表。

**空回滚：**空回滚的意思就是因为网络等问题，Try接口没有接收到该事务信息，直接触发了回滚操作。为了解决该问题，我们可以在Try阶段时，往事务控制表中增加一条记录，表示第一阶段执行完毕，标记初始化状态。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

**防悬挂：**防悬挂的意思是是 Try 由于网络拥堵而超时，Cancel 比 Try 接口先执行。我们可以在Cancel阶段时，先检查事务控制表是否存在记录，判断是不是空回滚了，如果没有相关记录，则往事务控制表中插入一条记录，标识已回滚状态，如果Try延时执行，那么检查事务控制表的内容，发现已经回滚，那么不执行任何操作

**幂等性：**和上面两种方案一致，采用事务控制表的方式来解决，当出现二阶段重复执行时，检查表内分支事务的信息，如果存在了，则不做操作。

## [Saga](http://seata.io/zh-cn/docs/user/saga.html)

Saga模式是一种长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者。他的性能很高，甚至在状态机定义时支持异步调用，但是缺点也很明显, 不保证 **隔离性**。事务会根据json配置的state来执行，如果前一个state的正向服务执行成功，那么就路由到下一个state并执行下一个state的正向服务，如果执行失败，那么基于CompensateState属性执行补偿服务。但是由于一阶段已经提交本地数据库事务，且没有进行"预留"动作，所以不能保证隔离性。

目前互联网中常用的解决隔离性的方案是在业务流程设计时遵循“宁可长款, 不可短款”的原则, **长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了**。所以在业务流程设计上一定是先扣款。有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。

## [XA](http://seata.io/zh-cn/docs/dev/mode/xa-mode.html)

XA模式是基于数据库的XA协议而来，他与AT模式相仿，但是他的锁机制更为严苛，并且不允许资源的重入。我了解的也很有限，因为在互联网公式中，该模式的使用率偏低。