<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSO单点登录</title>
    <link href="/2022/03/28/Distributed%20System/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <url>/2022/03/28/Distributed%20System/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="同域名方式"><a href="#同域名方式" class="headerlink" title="同域名方式"></a>同域名方式</h2><ol><li><p><strong>使用共享Cookie来解决Token共享问题。</strong></p><p>所谓共享Cookie，就是Cookie设置为顶域名，然后就可以在二级域名下的共享，举个例子：写在父域名stp.com下的Cookie，<a href="http://在s1.stp.com/">在s1.stp.com</a>、s2.stp.com等子域名都是可以共享访问的。</p></li><li><p><strong>使用Redis来解决Session共享问题。</strong></p><p>Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把 3 个系统的Session共享，采用Redis来实现。</p></li></ol><h3 id="Shiro-Session模式"><a href="#Shiro-Session模式" class="headerlink" title="Shiro Session模式"></a>Shiro Session模式</h3><p>Shiro标准模式是基于Session来做的，SessionID存储在Cookie里。也就意味着如果我们多个系统都采用Shiro框架认证。</p><p>那么当我们删除了Redis的Session后，所有系统都会全部注销。</p><h3 id="Sa-Token"><a href="#Sa-Token" class="headerlink" title="Sa-Token"></a>Sa-Token</h3><p>用户登录成功，会创建多个Session对象（其实就是Map集合之类的）存储到Redis里面，再返回浏览器一个Token标识，后续请求服务器检验该Cookie中的Token。</p><p>该Token里面存储了用户信息，是否登录等。</p><p>用户访问其他系统时，网关拦截校验Cookie中的Token是否正确，是否登录，然后再交由后续登录方法给用户加权限信息。</p><p>当用户点击某系统的注销后，先删除Cookie，再删除Redis里的Session信息。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT存入到Cookie里面，A系统首先登录，然后JWT存入到顶级域名的Cookie里面，B系统网关拦截后，重定向到SSO服务器，服务器获取Cookie是否存在并验证，成功后返回给B系统。</p><h2 id="不同域的CAS方式"><a href="#不同域的CAS方式" class="headerlink" title="不同域的CAS方式"></a>不同域的CAS方式</h2><blockquote><p>Spring Security有与<a href="https://github.com/apereo/cas">CAS</a>集成的便捷写法, 研发者只需要配置地址, 不需要关心如何统一认证.</p></blockquote><p>CAS （Central Authentication Service）中央认证服务</p><ol><li><p>A系统登录并重定向SSO 首先，用户想要访问系统A <a href="http://www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p><p><a href="http://www.sso.com/?service=www.java3y.com">http://www.sso.com?service=www.java3y.com</a></p></li><li><p>SSO进行认证并设置SSO域的Token，并重定向给A系统 sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</p><p>随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：</p><p><a href="http://www.java3y.com/?token=xxxxxxx">http://www.java3y.com?token=xxxxxxx</a></p></li><li><p>A系统携带Token去SSO验证，并确认登录 接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。</p></li><li><p>用户登录B系统，重定向到SSO，SSO检测Cookie里是否存在Token并验证 此时，用户想要访问系统B<a href="http://www.java4y.com受限的资源(比如说订单功能,订单功能需要登录后才能访问),系统b/">www.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B</a> <a href="http://www.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p><p><a href="http://www.sso.com/?service=www.java4y.com">http://www.sso.com?service=www.java4y.com</a></p></li><li><p>SSO发现用户已登录，将Token重定向B系统 注意，因为之前用户与认证中心<a href="http://www.sso.com已经建立了全局会话(当时已经把cookie保存到浏览器上了),所以这次系统b重定向到认证中心www.sso.com是可以带上cookie的./">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。</a> 认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下：</p><p><a href="http://www.java4y.com/?token=xxxxxxx">http://www.java4y.com?token=xxxxxxx</a></p></li><li><p>B系统携带Token去SSO验证，并确认登录 接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。</p></li></ol><h3 id="票据模式"><a href="#票据模式" class="headerlink" title="票据模式"></a>票据模式</h3><p>在CAS标准中，用户登录认证的操作如下。</p><ol><li>用户访问A系统，重定向SSO，并携带当前系统地址。</li><li>SSO进行登录，并生成 key &#x3D; CASTGC, value &#x3D; ${TGC}的Cookie，以及key &#x3D; ${TGC}, value &#x3D; ${TGT}的Session。</li><li>SSO分发ST给A系统，A系统携带ST去SSO验证，验证通过，A系统正常登录。</li><li>用户访问B系统，重定向SSO</li><li>SSO发现Cookie中有CASTGC的Cookie，获取到TGC的值去Session查找TGT是否存在，找到的话就说明登录过了。</li><li>SSO分发ST给B系统，B系统携带ST去SSO验证，验证通过，B系统正常登录。</li></ol><h3 id="一次注销，全端下线"><a href="#一次注销，全端下线" class="headerlink" title="一次注销，全端下线"></a>一次注销，全端下线</h3><p>SSO在被重定向过来时，将业务系统的项目地址存入到用户相关的Set集合里。</p><p>当某个系统点击注销按钮，将该请求发送至SSO中，让SSO遍历Set集合对地址后追加注销字符串，进行逐一下线操作，然后再注销SSO。</p><h3 id="本地服务"><a href="#本地服务" class="headerlink" title="本地服务"></a>本地服务</h3><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><ol><li>用户访问&#x2F;business&#x2F;index , 因为没登录, 被配置的<code>authenticationEntryPoint</code>发送SSO登录请求重定向至&#x2F;sso&#x2F;code?redirectUrl</li><li>SSO服务的默认未认证拦截器拦截到该请求, 重定向至SSO登录页面.</li><li>用户登录成功后, 交由研发人员实现SSO服务中的successHandler类进行处理, <code>authenticationDetailsSource.buildDetails(request)</code>设置details信息到Authentication里面, 记录日志等, 并根据savedRequest重定向到业务的index 或者 SSO的index</li><li>再次访问&#x2F;business&#x2F;index , 还是因为没登录, 被配置的<code>authenticationEntryPoint</code>发送SSO登录请求重定向至&#x2F;sso&#x2F;code?redirectUrl</li><li>这一次SSO通过已经存在的session发现认证了, 不再拦截, 进入code方法, 查询具体的客户端信息, 根据session中的用户信息与查询的客户端信息存入map, key&#x3D;code, value&#x3D;authentication, 再根据redirectUrl返回重定向至业务的post登录请求(&#x2F;ssoLogin)</li><li>这一次请求地址是&#x2F;ssoLogin, 该地址是子类构造器中定义的, 所以被<code>AbstractAuthenticationProcessingFilter</code>过滤器匹配到. 根据code参数, new一个Authentication, 并authenticationDetailsSource.buildDetails(request)设置details信息到Authentication里面, 并创建一个当前session并传入. 检查code参数是否存在, 不存在就重新去获取code, 存在就进入自定义认证逻辑<code>SsoAuthenticationProvider</code></li><li>该认证方法中进行远程调用&#x2F;sso&#x2F;verify方法, 通过code参数从map中删除该key并获取authentication对象, 然后返回user信息对象, 里面包含SSO的sessionid, 将他也放入authentication对象里面, 然后返回authentication <strong>在这一步中, 如果项目之间允许共享Redis, 则不需要将用户信息通过http的方式同步</strong></li><li>进入业务的登录成功successHandler类进行处理,将SSO的sessionid与当前业务的sessionid绑定放入域中, 获取savedRequest并重定向</li></ol><h4 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h4><ol><li>用户调用当前业务的登出方法, 该方法重定向到SSO登出方法</li><li>SSO登出方法根据配置好的所有业务模块信息, 循环获取所有的登出地址, 传入SSO的sessionId并进行调用</li><li>每一个业务登出方法处理都需要根据SSO的sessionid找到当前业务的sessionId, 然后注销.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Distributed System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oauth2</title>
    <link href="/2022/03/28/Distributed%20System/Oauth2/"/>
    <url>/2022/03/28/Distributed%20System/Oauth2/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><hr><p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><ol><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li><li>令牌可以被数据所有者撤销，会立即失效。</li><li>令牌有权限范围（scope），对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ol><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><hr><ul><li>Resource owner (资源拥有者) ：拥有该资源的最终用户，他有访问资源的账号密码（微信用户）</li><li>Resource server (资源服务器) ：拥有受保护资源的服务器，如果请求包含正确的访问令牌，可以访问资源（微信服务器）</li><li>Client (客户端) ：访问资源的客户端，会使用访问令牌去获取资源服务器的资源，可以是浏览器、移动设备或者服务器（戒毒网站）</li><li>Authentication server (认证服务器) ：用于认证用户的服务器，如果客户端认证通过，发放访问资源服务器的令牌（微信认证服务）</li></ul><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h3><h4 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h4><ul><li><strong>会不会有其他应用冒充第三方应用骗取授权？</strong> ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。</li><li><strong>为什么要先发放授权码，再用授权码换令牌？</strong> 这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的，换而言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中被泄漏的风险。</li><li><strong>为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？</strong> 这是为了缓解 OAuth2 在实际应用中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短，譬如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。</li></ul><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。</p><ol><li>A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。 <em><strong>在这一步请求时, 如果检测到scope参数, 一般会弹出具体的授权页面, 用户确定授权才会往下走, 这也是为什么需要authorize, 而不是直接请求token的原因</strong></em></li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// response_type参数表示要求返回授权码（code）</span><br><span class="hljs-comment">// client_id参数让 B 知道是谁在请求, 一个应用一个id</span><br><span class="hljs-comment">// redirect_uri参数是 B 接受或拒绝请求后的跳转网址</span><br><br>**<span class="hljs-comment">// scope：参数表示要求的授权范围（这里是只读）, 也可以不传</span><br><span class="hljs-comment">// scope：如果传了, 服务端需要检查去数据库该应用的scope是否与之吻合, 不符合直接返回错误信息</span><br><span class="hljs-comment">// scope：如果不传, 则表示静默授权, 不返回任何权限scope, 只表明登录了, 所以也不能获取任何信息, 当然你也可以去查询该用户的所有scope, 后续返回给他**</span><br>**<span class="hljs-comment">// secret：一开始不传是因为后面有重定向，重定向是可感知的，有可能被其他网站拿到**</span><br>https:<span class="hljs-comment">//b.com/oauth/authorize?</span><br>  response_type=code&amp;<br>  client_id=CLIENT_ID&amp;<br>  redirect_uri=CALLBACK_URL&amp;<br>  scope=read<br></code></pre></td></tr></table></figure><ol><li>用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// code参数就是授权码, 需要设置过期时间, 可以放在redis里面</span><br><span class="hljs-comment">// 正常使用一次以后, 就要被销毁, 不允许第二次使用</span><br>https:<span class="hljs-comment">//a.com/callback?code=AUTHORIZATION_CODE</span><br></code></pre></td></tr></table></figure><ol><li>A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">**<span class="hljs-comment">// client_id参数让 B 知道是谁在请求, 一个应用一个id</span><br><span class="hljs-comment">// client_secret参数用来让B确认A的身份, 是应用的保密秘钥, 可以让服务器分发一个加密秘钥, 然后服务器有解密的算法**</span><br><br>**<span class="hljs-comment">// 有些应用在让第三方请求时, 会有一个前置接口, 让第三方公司输入应用名称等信息, 然后返回给client_id和client_secret**</span><br>**<span class="hljs-comment">// 如果是自己的应用, 那么自己约定好这两个信息, 让客户端及服务端都能知晓就可以了**</span><br><br><span class="hljs-comment">// grant_type参数的值是AUTHORIZATION_CODE, 表示采用的授权方式是授权码</span><br><span class="hljs-comment">// code参数是上一步拿到的授权码</span><br><span class="hljs-comment">// redirect_uri参数是令牌颁发后的回调网址</span><br>https:<span class="hljs-comment">//b.com/oauth/token?</span><br> client_id=CLIENT_ID&amp;<br> client_secret=CLIENT_SECRET&amp;<br> grant_type=authorization_code&amp;<br> code=AUTHORIZATION_CODE&amp;<br> redirect_uri=CALLBACK_URL<br></code></pre></td></tr></table></figure><ol><li>B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span>    <br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ONWVJzfOv1XidEdeBAdqPxYGL60toIzhzHRwp1ySPHMEKWFbp5FIp3FuaQ3g&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bearer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;REFRESH_TOKEN&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// Set集合</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">100101</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// 或者</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ONWVJzfOv1XidEdeBAdqPxYGL60toIzhzHRwp1ySPHMEKWFbp5FIp3FuaQ3g&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;SshGOiUl4w9UIePixwQzvXjlnddMi52xgviM8S4RPm26m1bBgJInpSXC4AND&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">7199</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;refresh_expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">2591999</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 刷新令牌的失效时间</span><br>  <span class="hljs-attr">&quot;client_id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1001</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10001</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// Set集合</span><br>  <span class="hljs-attr">&quot;openid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;gr_SwoIN0MC1ewxHX_vfCW3BothWDZMMtx__&quot;</span> <span class="hljs-comment">// JWT</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h3><p>如果你高度信任某个应用，<strong>RFC 6749</strong> 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p><ol><li>A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// client_id参数让 B 知道是谁在请求, 一个应用一个id</span><br><span class="hljs-comment">// client_secret参数用来让B确认A的身份, 是应用的保密秘钥, 自己配一个</span><br><span class="hljs-comment">// grant_type参数的值是password, 表示采用的授权方式是密码式</span><br><span class="hljs-comment">// username和password是 B 的用户名和密码。</span><br>https:<span class="hljs-comment">//oauth.b.com/oauth/token?</span><br>  grant_type=password&amp;<br>  username=USERNAME&amp;<br>  password=PASSWORD&amp;<br>  client_secret=CLIENT_SECRET&amp;<br>  client_id=CLIENT_ID&amp;<br>  scope=scope<br></code></pre></td></tr></table></figure><ol><li>B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</li></ol><p>这种方式需要用户给出自己的用户名&#x2F;密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h3 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a><strong>隐藏式</strong></h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。**RFC 6749 **就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</p><ol><li>A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://b.com/oauth/authorize?<br>  response_type=token&amp;<br>  client_id=CLIENT_ID&amp;<br>  redirect_uri=CALLBACK_URL&amp;<br>  scope=read<br>上面 URL 中，`response_type`参数为`token`，表示要求直接返回令牌。<br></code></pre></td></tr></table></figure><ol><li>用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://a.com/callback#token=ACCESS_TOKEN<br>上面 URL 中，`token`参数就是令牌，A 网站因此直接在前端拿到令牌。<br></code></pre></td></tr></table></figure><h3 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a><strong>凭证式</strong></h3><p>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</p><ol><li>A 应用在命令行向 B 发出请求。</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://oauth.b.com/token?<br>  grant_type=client_credentials&amp;<br>  client_id=CLIENT_ID&amp;<br>  client_secret=CLIENT_SECRET<br>上面 URL 中，`grant_type`参数等于`client_credentials`表示采用凭证式，`client_id`和`client_secret`用来让 B 确认 A 的身份。<br></code></pre></td></tr></table></figure><ol><li><p>B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p></li></ol><h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><hr><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl -H <span class="hljs-string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \<br><span class="hljs-string">&quot;https://api.b.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面命令中，ACCESS_TOKEN就是拿到的令牌。</p><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><hr><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// grant_type参数为refresh_token表示要求更新令牌</span><br><span class="hljs-comment">// client_id参数和client_secret参数用于确认身份</span><br><span class="hljs-comment">// refresh_token参数就是用于更新令牌的令牌。</span><br>https:<span class="hljs-comment">//b.com/oauth/token?</span><br>  grant_type=refresh_token&amp;<br>  client_id=CLIENT_ID&amp;<br>  client_secret=CLIENT_SECRET&amp;<br>  refresh_token=REFRESH_TOKEN<br></code></pre></td></tr></table></figure><h2 id="第三方登录原理"><a href="#第三方登录原理" class="headerlink" title="第三方登录原理"></a>第三方登录原理</h2><hr><p>所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>举例来说，A 网站允许 GitHub 登录，背后就是下面的流程。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">**Authorize**<br>1. A 网站让用户跳转到 GitHub。<br><br>2. GitHub 要求用户登录，然后询问&quot;A 网站要求获得 xx 权限，你是否同意？&quot;<br><br>3. 用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。<br><br>**Token**<br>4. A 网站使用授权码，向 GitHub 请求令牌。<br><br>5. GitHub 返回令牌.<br><br>6. A 网站使用令牌，向 GitHub 请求用户数据。<br></code></pre></td></tr></table></figure><h3 id="应用登记"><a href="#应用登记" class="headerlink" title="应用登记"></a>应用登记</h3><p>一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。</p><p>所以，你要先去 GitHub 登记一下。当然，我已经登记过了，你使用我的登记信息也可以，但为了完整走一遍流程，还是建议大家自己登记。这是免费的。</p><p>访问这个网址，填写登记表。</p><p><img src="/image/Oauth2/WX20220328-114828@2x.png" alt="img"></p><p>应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>。</p><p>跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p><p>提交表单以后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码。</p><h3 id="跳转授权"><a href="#跳转授权" class="headerlink" title="跳转授权"></a>跳转授权</h3><p>在你自己搭建的Web网站中，对Github进行授权访问。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://github.com/login/oauth/authorize?<br>  client_id=7e015d8ce32370079895&amp;<br>  redirect_uri=http://localhost:8080/oauth/redirect<br></code></pre></td></tr></table></figure><p>这个 URL 指向 GitHub 的 OAuth 授权网址，带有两个参数：<code>client_id</code>告诉 GitHub 谁在请求，<code>redirect_uri</code>是稍后跳转回来的网址。</p><p>用户点击到了 GitHub，GitHub 会要求用户登录，确保是本人在操作。</p><h3 id="获取授权码"><a href="#获取授权码" class="headerlink" title="获取授权码"></a>获取授权码</h3><p>登录后，GitHub 询问用户，该应用正在请求数据，你是否同意授权。</p><p><img src="/image/Oauth2/WX20220328-114914@2x.png" alt="img"></p><p>用户同意授权， GitHub 就会跳转到<code>redirect_uri</code>指定的跳转网址，并且带上授权码，跳转回来的 URL 就是下面的样子。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Http">http://localhost:8080/oauth/redirect?<br>  code=859310e7cecc9196f4af<br></code></pre></td></tr></table></figure><p>后端收到这个请求以后，就拿到了授权码（code参数）。</p><h3 id="获取令牌"><a href="#获取令牌" class="headerlink" title="获取令牌"></a>获取令牌</h3><p>后端使用这个授权码，向 GitHub 请求令牌。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://github.com/login/oauth/access_token?<br>    client_id=$&#123;clientID&#125;&amp;<br>    client_secret=$&#123;clientSecret&#125;&amp;<br>    code=$&#123;requestToken&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，GitHub 的令牌接口<code>https://github.com/login/oauth/access_token</code>需要提供三个参数。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Http">client_id：客户端的 ID<br><br>client_secret：客户端的密钥<br><br>code：授权码<br></code></pre></td></tr></table></figure><p>作为回应，GitHub 会返回一段 JSON 数据，里面包含了令牌accessToken。</p><h3 id="API数据"><a href="#API数据" class="headerlink" title="API数据"></a>API数据</h3><p>有了令牌以后，就可以向 API 请求数据了。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Http">https://api.github.com/user,<br>  headers: &#123;<br>    accept: &#x27;application/json&#x27;,<br>    Authorization: &#x27;Bearer $&#123;accessToken&#125;&#x27;<br>  &#125;<br></code></pre></td></tr></table></figure><p>上面代码中，GitHub API 的地址是<code>https://api.github.com/user</code>，请求的时候必须在 HTTP 头信息里面带上令牌<code>Authorization: token 361507da</code>。</p><p>然后，就可以拿到用户数据，得到用户的身份。</p>]]></content>
    
    
    <categories>
      
      <category>Distributed System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2022/03/28/Distributed%20System/Nginx/"/>
    <url>/2022/03/28/Distributed%20System/Nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a><a href="https://openresty.org/cn/">OpenResty</a></h2><p>OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p><p>OpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。</p><p>OpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I&#x2F;O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p>]]></content>
    
    
    <categories>
      
      <category>Distributed System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Feign</title>
    <link href="/2022/03/28/Spring/Feign/"/>
    <url>/2022/03/28/Spring/Feign/</url>
    
    <content type="html"><![CDATA[<p>SpringCloud feign 对Netflix feign进行了包装和增强，本文从源码角度梳理一个请求链路中参与的各个组件及其它们如何配合交互完成请求。组件包括feign、ribbon、hystrix、sleuth等</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="EnableFeignClients"><a href="#EnableFeignClients" class="headerlink" title="@EnableFeignClients"></a>@EnableFeignClients</h3><p>该注解通过import方式，引入FeignClientsRegistrar。先注册默认配置，再注册所有的feignClient BeanDefinition。</p><p>扫描到所有@FeignClient的BeanDefinition后，包装成FeignClientFactoryBean，然后注册到spring上下文中。</p><h3 id="FeignClientFactoryBean"><a href="#FeignClientFactoryBean" class="headerlink" title="FeignClientFactoryBean"></a>FeignClientFactoryBean</h3><p>完成了调用前的所有准备工作，如FeignContext，Feign.builder的创建、判断是否需要负载均衡及设置及Feign的代理类的创建等。</p><p>Feign 的动态代理创建完成，并交由Spring容器管理。第二阶段的初始化阶段至此结束。http请求发生时，创建的代理对象最终聚合ribbon、hystrix、sleuth的功能完成整个调用链路的增强或跟踪。</p><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息；</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by macro on 2019/9/5.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br>  <span class="hljs-meta">@Bean</span><br>  Logger.Level <span class="hljs-title function_">feignLoggerLevel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>  <span class="hljs-attr">com.macro.cloud.service.UserService:</span> <span class="hljs-string">debug</span><br><br></code></pre></td></tr></table></figure><h2 id="Used-Config"><a href="#Used-Config" class="headerlink" title="Used Config"></a>Used Config</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#在Feign中开启Hystrix</span><br>  <span class="hljs-attr">compression:</span><br>  <span class="hljs-attr">request:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否对请求进行GZIP压缩</span><br>    <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/xml,application/xml,application/json</span> <span class="hljs-comment">#指定压缩的请求数据类型</span><br>    <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span> <span class="hljs-comment">#超过该大小的请求会被压缩</span><br>  <span class="hljs-attr">response:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否对响应进行GZIP压缩</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span> <span class="hljs-comment">#修改日志级别</span><br>  <span class="hljs-attr">com.macro.cloud.service.UserService:</span> <span class="hljs-string">debug</span><br><br></code></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>在初始化的最后，创建了InvocationHandler，在请求发生时invoke()方法将被调用。如果引入了hystrix，那么就是调用HystrixInvocationHandler，该方法内部调用了HystrixCommand。</p><p>在run()方法中，调用对应的methodHandler的invoke()方法。在这里有获取URL，封装ribbon请求，负载均衡，并最终执行httpclient调用。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><a href="https://www.jianshu.com/p/769081fe8d95">Feign 调用过程分析</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GateWay</title>
    <link href="/2022/03/28/Spring/GateWay/"/>
    <url>/2022/03/28/Spring/GateWay/</url>
    
    <content type="html"><![CDATA[<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="GlobalFilter"><a href="#GlobalFilter" class="headerlink" title="GlobalFilter"></a>GlobalFilter</h4><p>全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</p><ul><li><strong>可以实现此过滤器来完成鉴权功能, 比如ruoyi-cloud项目的AuthFilter</strong>  <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 网关鉴权</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ruoyi</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(AuthFilter.class);<br><br>    <span class="hljs-comment">// 排除过滤的 uri 地址，nacos自行添加</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IgnoreWhiteProperties ignoreWhite;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span><br>    &#123;<br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        ServerHttpRequest.<span class="hljs-type">Builder</span> <span class="hljs-variable">mutate</span> <span class="hljs-operator">=</span> request.mutate();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getURI().getPath();<br>        <span class="hljs-comment">// 跳过不需要验证的路径</span><br>        <span class="hljs-keyword">if</span> (StringUtils.matches(url, ignoreWhite.getWhites()))<br>        &#123;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> getToken(request);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token))<br>        &#123;<br>            <span class="hljs-keyword">return</span> unauthorizedResponse(exchange, <span class="hljs-string">&quot;令牌不能为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtils.parseToken(token);<br>        <span class="hljs-keyword">if</span> (claims == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> unauthorizedResponse(exchange, <span class="hljs-string">&quot;令牌已过期或验证不正确！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userkey</span> <span class="hljs-operator">=</span> JwtUtils.getUserKey(claims);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">islogin</span> <span class="hljs-operator">=</span> redisService.hasKey(getTokenKey(userkey));<br>        <span class="hljs-keyword">if</span> (!islogin)<br>        &#123;<br>            <span class="hljs-keyword">return</span> unauthorizedResponse(exchange, <span class="hljs-string">&quot;登录状态已过期&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userid</span> <span class="hljs-operator">=</span> JwtUtils.getUserId(claims);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> JwtUtils.getUserName(claims);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(userid) || StringUtils.isEmpty(username))<br>        &#123;<br>            <span class="hljs-keyword">return</span> unauthorizedResponse(exchange, <span class="hljs-string">&quot;令牌验证失败&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置用户信息到请求</span><br>        addHeader(mutate, SecurityConstants.USER_KEY, userkey);<br>        addHeader(mutate, SecurityConstants.DETAILS_USER_ID, userid);<br>        addHeader(mutate, SecurityConstants.DETAILS_USERNAME, username);<br>        <span class="hljs-comment">// 内部请求来源参数清除</span><br>        removeHeader(mutate, SecurityConstants.FROM_SOURCE);<br>        <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().request(mutate.build()).build());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHeader</span><span class="hljs-params">(ServerHttpRequest.Builder mutate, String name, Object value)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">valueStr</span> <span class="hljs-operator">=</span> value.toString();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">valueEncode</span> <span class="hljs-operator">=</span> ServletUtils.urlEncode(valueStr);<br>        mutate.header(name, valueEncode);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeHeader</span><span class="hljs-params">(ServerHttpRequest.Builder mutate, String name)</span><br>    &#123;<br>        mutate.headers(httpHeaders -&gt; httpHeaders.remove(name)).build();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">unauthorizedResponse</span><span class="hljs-params">(ServerWebExchange exchange, String msg)</span><br>    &#123;<br>        log.error(<span class="hljs-string">&quot;[鉴权异常处理]请求路径:&#123;&#125;&quot;</span>, exchange.getRequest().getPath());<br>        <span class="hljs-keyword">return</span> ServletUtils.webFluxResponseWriter(exchange.getResponse(), msg, HttpStatus.UNAUTHORIZED);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取缓存key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getTokenKey</span><span class="hljs-params">(String token)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> CacheConstants.LOGIN_TOKEN_KEY + token;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取请求token</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getToken</span><span class="hljs-params">(ServerHttpRequest request)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeaders().getFirst(TokenConstants.AUTHENTICATION);<br>        <span class="hljs-comment">// 如果前端设置了令牌前缀，则裁剪掉前缀</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(token) &amp;&amp; token.startsWith(TokenConstants.PREFIX))<br>        &#123;<br>            token = token.replaceFirst(TokenConstants.PREFIX, StringUtils.EMPTY);<br>        &#125;<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">200</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="GatewayFilter"><a href="#GatewayFilter" class="headerlink" title="GatewayFilter"></a>GatewayFilter</h4><p>需要通过 <code>spring.cloud.routes.filters</code> 配置在<strong>具体路由</strong>下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上。</p><h4 id="Hystrix-GatewayFilter"><a href="#Hystrix-GatewayFilter" class="headerlink" title="Hystrix GatewayFilter"></a>Hystrix GatewayFilter</h4><p>Hystrix 过滤器允许你将断路器功能添加到<strong>具体的网关路由</strong>中，使你的服务免受级联故障的影响，并提供服务降级处理。</p><ul><li><p>要开启断路器功能，我们需要在pom.xml中添加Hystrix的相关依赖：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>然后添加相关服务降级的处理类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by macro on 2019/9/25.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FallbackController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/fallback&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">fallback</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String,Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        result.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-literal">null</span>);<br>        result.put(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-string">&quot;Get request fallback!&quot;</span>);<br>        result.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在application-filter.yml中添加相关配置，当路由出错时会转发到服务降级处理的控制器上：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">hystrix_route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8201</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET</span><br>          <span class="hljs-attr">filters:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hystrix</span><br>              <span class="hljs-attr">args:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">fallbackcmd</span><br>                <span class="hljs-attr">fallbackUri:</span> <span class="hljs-string">forward:/fallback</span><br></code></pre></td></tr></table></figure></li><li><p>关闭user-service，调用该地址进行测试：<a href="http://localhost:9201/user/1">http://localhost:9201/user/1</a> ，发现已经返回了服务降级的处理信息。</p></li></ul><p><img src="http://www.macrozheng.com/images/springcloud_gateway_03.png" title="image"></p><h3 id="异常拦截器"><a href="#异常拦截器" class="headerlink" title="异常拦截器"></a>异常拦截器</h3><h4 id="WebExceptionHandler"><a href="#WebExceptionHandler" class="headerlink" title="WebExceptionHandler"></a>WebExceptionHandler</h4><p>在该异常处理中, 可以对 <code>服务未找到</code> 或者<code>sentinel</code>的相关异常 (BlockException) 进行判断拦截, 并返回对应错误信息, 告知用户</p><p>具体可查看<strong>ruoyi</strong>项目的相关代码, 写的比较完全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 网关统一异常处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ruoyi</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Order(-1)</span> <span class="hljs-comment">//优先级一定要小于内置ResponseStatusExceptionHandler, 经过它处理的获取对应错误类的 响应码</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ErrorWebExceptionHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(GatewayExceptionHandler.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange, Throwable ex)</span><br>    &#123;<br>        <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br><br>        <span class="hljs-keyword">if</span> (exchange.getResponse().isCommitted())<br>        &#123;<br>            <span class="hljs-keyword">return</span> Mono.error(ex);<br>        &#125;<br><br>        String msg;<br><br>        <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> NotFoundException)<br>        &#123;<br>            msg = <span class="hljs-string">&quot;服务未找到&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ResponseStatusException)<br>        &#123;<br>            <span class="hljs-type">ResponseStatusException</span> <span class="hljs-variable">responseStatusException</span> <span class="hljs-operator">=</span> (ResponseStatusException) ex;<br>            msg = responseStatusException.getMessage();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            msg = <span class="hljs-string">&quot;内部服务器错误&quot;</span>;<br>        &#125;<br><br>        log.error(<span class="hljs-string">&quot;[网关异常处理]请求路径:&#123;&#125;,异常信息:&#123;&#125;&quot;</span>, exchange.getRequest().getPath(), ex.getMessage());<br><br>        <span class="hljs-keyword">return</span> ServletUtils.webFluxResponseWriter(response, msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义限流异常处理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> ruoyi</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelFallbackHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebExceptionHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">writeResponse</span><span class="hljs-params">(ServerResponse response, ServerWebExchange exchange)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> ServletUtils.webFluxResponseWriter(exchange.getResponse(), <span class="hljs-string">&quot;请求超过最大数，请稍候再试&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange, Throwable ex)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (exchange.getResponse().isCommitted())<br>        &#123;<br>            <span class="hljs-keyword">return</span> Mono.error(ex);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!BlockException.isBlockException(ex))<br>        &#123;<br>            <span class="hljs-keyword">return</span> Mono.error(ex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> handleBlockedRequest(exchange, ex).flatMap(response -&gt; writeResponse(response, exchange));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Mono&lt;ServerResponse&gt; <span class="hljs-title function_">handleBlockedRequest</span><span class="hljs-params">(ServerWebExchange exchange, Throwable throwable)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> GatewayCallbackManager.getBlockHandler().handleRequest(exchange, throwable);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Canal</title>
    <link href="/2022/03/28/Spring/Canal/"/>
    <url>/2022/03/28/Spring/Canal/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-Canal"><a href="#What-is-Canal" class="headerlink" title="What is Canal?"></a>What is Canal?</h2><p>Canal is a high performance data synchronization system based on MySQL binary log. Canal is widely used in Alibaba group (including <a href="https://www.taobao.com/">https://www.taobao.com</a>) to provide reliable low latency incremental data pipeline.</p><p>Canal是一个基于 MySQL 二进制日志的高性能数据同步系统。Canal 在阿里巴巴集团(包括 <a href="https://www.taobao.com/">https://www.taobao.com</a> )中被广泛应用，以提供可靠的低延迟增量数据流水线。</p><p>Canal Server is capable of parsing MySQL binlog and subscribe to the data change, while Canal Client can be implemented to broadcast the change to anywhere, e.g. database and Apache Kafka.</p><p>Canal Server能够解析 MySQL binlog 并订阅数据更改，而 Canal Client 可以实现将更改广播到任何地方，例如数据库和 Apache Kafka。</p><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><h3 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h3><p>canal-admin设计上是为canal提供整体配置管理、节点运维等面向运维的功能，提供相对友好的WebUI操作界面，方便更多用户快速和安全的操作。</p><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>canal-adapter是为了让研发人员方便快速的将增量数据发送到ElasticSearch等Nosql中，减少Java代码的编写。</p><h3 id="Deployer"><a href="#Deployer" class="headerlink" title="Deployer"></a>Deployer</h3><p>canal-deployer是一个模仿Mysql备机的小型服务，用于获取数据库日志抓取数据。</p><h2 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h2><h3 id="1-Schedule"><a href="#1-Schedule" class="headerlink" title="1. Schedule"></a>1. Schedule</h3><p>使用Springboot定时器，定时抓取Canal中的增量数据，并解析，然后发送到自己想去的地方。官方中也是使用此做法。</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">Get <span class="hljs-regexp">/knowledge/</span>_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>:&#123;<br>    <span class="hljs-string">&quot;term&quot;</span>:&#123;<br>      <span class="hljs-string">&quot;searchTypeId.keyword&quot;</span>:<span class="hljs-string">&quot;3&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hikari</title>
    <link href="/2022/03/28/Spring/Hikari/"/>
    <url>/2022/03/28/Spring/Hikari/</url>
    
    <content type="html"><![CDATA[<p>Hikari是Spring在2.0之后的默认jdbc连接工具, 相比于常用的Druid, 他的连接速度加快, 字节码精简, 并发读写效率提高</p><p>但是Druid有强大的Sql监控特性以及额外的扩展功能</p><h2 id="主要构件"><a href="#主要构件" class="headerlink" title="主要构件"></a>主要构件</h2><ul><li>HikariDataSource<br>是一切的入口, 用于获取连接的主要类</li><li>HikariConfig<br>配置类</li><li>HikariPool<br>持有连接池, 延时maxlifetime任务, 定时keepalive清理任务的控制类</li><li>ConcurrentBag<br>连接池, 内部持有了连接对象的集合, 用于获取 , 删除, 增加连接</li><li>PoolEntry<br>具体的连接对象, 持有实际的物理连接Connection</li><li>PoolBase<br>主要用于生产一个DriverDataSource类, 给new PoolEntry()时使用</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><a href="https://juejin.cn/post/6986812265357901860">HikariCP源码流程</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ribbon</title>
    <link href="/2022/03/28/Spring/Ribbon/"/>
    <url>/2022/03/28/Spring/Ribbon/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在微服务架构中，很多服务都会部署多个，其他服务去调用该服务的时候，如何保证负载均衡是个不得不去考虑的问题。负载均衡可以增加系统的可用性和扩展性，当我们使用RestTemplate来调用其他服务时，Ribbon可以很方便的实现负载均衡功能。</p></blockquote><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate是一个HTTP客户端，使用它我们可以方便的调用HTTP接口，支持GET、POST、PUT、DELETE等方法。</p><h3 id="LoadBalanced"><a href="#LoadBalanced" class="headerlink" title="LoadBalanced"></a>LoadBalanced</h3><p>使用Ribbon的负载均衡功能非常简单，和直接使用RestTemplate没什么两样，只需给RestTemplate添加一个@LoadBalanced即可。</p><ul><li>com.netflix.loadbalancer.RandomRule：从提供服务的实例中以随机的方式；</li><li>com.netflix.loadbalancer.RoundRobinRule：以线性轮询的方式，就是维护一个计数器，从提供服务的实例中按顺序选取，第一次选第一个，第二次选第二个，以此类推，到最后一个以后再从头来过；</li><li>com.netflix.loadbalancer.RetryRule：在RoundRobinRule的基础上添加重试机制，即在指定的重试时间内，反复使用线性轮询策略来选择可用实例；</li><li>com.netflix.loadbalancer.WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择；</li><li>com.netflix.loadbalancer.BestAvailableRule：选择并发较小的实例；</li><li>com.netflix.loadbalancer.AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例；</li><li>com.netflix.loadbalancer.ZoneAwareLoadBalancer：采用双重过滤，同时过滤不是同一区域的实例和故障实例，选择并发较小的实例。</li></ul><h3 id="Used-Config"><a href="#Used-Config" class="headerlink" title="Used Config"></a>Used Config</h3><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span><br>  <span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment">#服务请求连接超时时间（毫秒）</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#服务请求处理超时时间（毫秒）</span><br>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#对超时请求启用重试机制</span><br>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment">#切换重试实例的最大个数</span><br>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 切换实例后重试最大次数</span><br>  <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment">#修改负载均衡算法</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mycat</title>
    <link href="/2022/03/28/Spring/Mycat/"/>
    <url>/2022/03/28/Spring/Mycat/</url>
    
    <content type="html"><![CDATA[<p>看了一下Mycat<a href="https://www.yuque.com/books/share/6606b3b6-3365-4187-94c4-e51116894695/bef923fb8acc57e0f805d45ef7782670">官方文档</a>，对于MGR、MHA等都有非常好的兼容模式，可以实现动态数据源更改，但是使用似乎不太广泛。</p>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hystrix</title>
    <link href="/2022/03/28/Spring/Hystrix/"/>
    <url>/2022/03/28/Spring/Hystrix/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在微服务架构中，服务与服务之间通过远程调用的方式进行通信，一旦某个被调用的服务发生了故障，其依赖服务也会发生故障，此时就会发生故障的蔓延，最终导致系统瘫痪。Hystrix实现了断路器模式，当某个服务发生故障时，通过断路器的监控，给调用方返回一个错误响应，而不是长时间的等待，这样就不会使得调用方由于长时间得不到响应而占用线程，从而防止故障的蔓延。Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p></blockquote><h4 id="Used-Parameters"><a href="#Used-Parameters" class="headerlink" title="Used Parameters"></a>Used Parameters</h4><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。</li></ul><h3 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h3><p><img src="https://res.craft.do/user/full/2c016c68-2ea0-5513-42ea-5813d216a654/doc/64F8465D-ECA0-4FC5-8B4D-195A84183BDB/AE24F0F6-D141-4924-8387-28C3C3D9AF70_2" title="image"></p><p><strong>适用场景</strong>：</p><ul><li><strong>线程池技术</strong>，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。</li><li><strong>信号量技术</strong>，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。</li></ul><h3 id="Request-Cache"><a href="#Request-Cache" class="headerlink" title="Request Cache"></a>Request Cache</h3><p>在一次请求上下文中，如果有多个 command，参数都是一样的，调用的接口也是一样的，而结果可以认为也是一样的。那么这个时候，我们可以让第一个 command 执行返回的结果缓存在内存中，然后这个请求上下文后续的其它对这个依赖的调用全部从内存中取出缓存结果就可以了。</p><p>这样的话，好处在于不用在一次请求上下文中反复多次执行一样的 command，<strong>避免重复执行网络请求，提升整个请求的性能</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheResult(cacheKeyMethod = &quot;getCacheKey&quot;)</span><br><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;getDefaultUser&quot;, commandKey = &quot;getUserCache&quot;)</span><br>    <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">getUserCache</span><span class="hljs-params">(Long id)</span> &#123;<br>    LOGGER.info(<span class="hljs-string">&quot;getUserCache id:&#123;&#125;&quot;</span>, id);<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(userServiceUrl + <span class="hljs-string">&quot;/user/&#123;1&#125;&quot;</span>, CommonResult.class, id);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为缓存生成key的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCacheKey</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> String.valueOf(id);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HystrixCollapser-请求合并"><a href="#HystrixCollapser-请求合并" class="headerlink" title="HystrixCollapser 请求合并"></a>HystrixCollapser 请求合并</h3><ul><li>batchMethod：用于设置请求合并的方法；</li><li>collapserProperties：请求合并属性，用于控制实例属性，有很多；</li><li>timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；</li></ul><ol><li>在UserHystrixController中添加testCollapser方法，这里我们先进行两次服务调用，再间隔200ms以后进行第三次服务调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/testCollapser&quot;)</span><br><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">testCollapser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>  Future&lt;User&gt; future1 = userService.getUserFuture(<span class="hljs-number">1L</span>);<br>  Future&lt;User&gt; future2 = userService.getUserFuture(<span class="hljs-number">2L</span>);<br>  future1.get();<br>  future2.get();<br>  ThreadUtil.safeSleep(<span class="hljs-number">200</span>);<br>  Future&lt;User&gt; future3 = userService.getUserFuture(<span class="hljs-number">3L</span>);<br>  future3.get();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-string">&quot;操作成功&quot;</span>, <span class="hljs-number">200</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>使用@HystrixCollapser实现请求合并，所有对getUserFuture的的多次调用都会转化为对getUserByIds的单次调用：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HystrixCollapser(batchMethod = &quot;getUserByIds&quot;,collapserProperties = &#123;</span><br><span class="hljs-meta">  @HystrixProperty(name = &quot;timerDelayInMilliseconds&quot;, value = &quot;100&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> Future&lt;User&gt; <span class="hljs-title function_">getUserFuture</span><span class="hljs-params">(Long id)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncResult</span>&lt;User&gt;()&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> User <span class="hljs-title function_">invoke</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">CommonResult</span> <span class="hljs-variable">commonResult</span> <span class="hljs-operator">=</span> restTemplate.getForObject(userServiceUrl + <span class="hljs-string">&quot;/user/&#123;1&#125;&quot;</span>, CommonResult.class, id);<br>    <span class="hljs-type">Map</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (Map) commonResult.getData();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> BeanUtil.mapToBean(data,User.class,<span class="hljs-literal">true</span>);<br>    LOGGER.info(<span class="hljs-string">&quot;getUserById username:&#123;&#125;&quot;</span>, user.getUsername());<br>    <span class="hljs-keyword">return</span> user;<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@HystrixCommand</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> &#123;<br>  LOGGER.info(<span class="hljs-string">&quot;getUserByIds:&#123;&#125;&quot;</span>, ids);<br>  <span class="hljs-type">CommonResult</span> <span class="hljs-variable">commonResult</span> <span class="hljs-operator">=</span> restTemplate.getForObject(userServiceUrl + <span class="hljs-string">&quot;/user/getUserByIds?ids=&#123;1&#125;&quot;</span>, CommonResult.class, CollUtil.join(ids,<span class="hljs-string">&quot;,&quot;</span>));<br>  <span class="hljs-keyword">return</span> (List&lt;User&gt;) commonResult.getData();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Used-Config"><a href="#Used-Config" class="headerlink" title="Used Config"></a>Used Config</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">command:</span> <span class="hljs-comment">#用于控制HystrixCommand的行为</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">execution:</span><br>    <span class="hljs-attr">isolation:</span><br>      <span class="hljs-attr">strategy:</span> <span class="hljs-string">THREAD</span> <span class="hljs-comment">#控制HystrixCommand的隔离策略，THREAD-&gt;线程池隔离策略(默认)，SEMAPHORE-&gt;信号量隔离策略</span><br>      <span class="hljs-attr">thread:</span><br>      <span class="hljs-attr">timeoutInMilliseconds:</span> <span class="hljs-number">1000</span> <span class="hljs-comment">#配置HystrixCommand执行的超时时间，执行超过该时间会进行服务降级处理</span><br>      <span class="hljs-attr">interruptOnTimeout:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#配置HystrixCommand执行超时的时候是否要中断</span><br>      <span class="hljs-attr">interruptOnCancel:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#配置HystrixCommand执行被取消的时候是否要中断</span><br>      <span class="hljs-attr">timeout:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#配置HystrixCommand的执行是否启用超时时间</span><br>      <span class="hljs-attr">semaphore:</span><br>      <span class="hljs-attr">maxConcurrentRequests:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#当使用信号量隔离策略时，用来控制并发量的大小，超过该并发量的请求会被拒绝</span><br>    <span class="hljs-attr">fallback:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#用于控制是否启用服务降级</span><br>    <span class="hljs-attr">circuitBreaker:</span> <span class="hljs-comment">#用于控制HystrixCircuitBreaker的行为</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#用于控制断路器是否跟踪健康状况以及熔断请求</span><br>    <span class="hljs-attr">requestVolumeThreshold:</span> <span class="hljs-number">20</span> <span class="hljs-comment">#超过该请求数的请求会被拒绝</span><br>    <span class="hljs-attr">forceOpen:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#强制打开断路器，拒绝所有请求</span><br>    <span class="hljs-attr">forceClosed:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#强制关闭断路器，接收所有请求</span><br>    <span class="hljs-attr">requestCache:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#用于控制是否开启请求缓存</span><br>  <span class="hljs-attr">collapser:</span> <span class="hljs-comment">#用于控制HystrixCollapser的执行行为</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">maxRequestsInBatch:</span> <span class="hljs-number">100</span> <span class="hljs-comment">#控制一次合并请求合并的最大请求数</span><br>    <span class="hljs-attr">timerDelayinMilliseconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#控制多少毫秒内的请求会被合并成一个</span><br>    <span class="hljs-attr">requestCache:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#控制合并请求是否开启缓存</span><br>  <span class="hljs-attr">threadpool:</span> <span class="hljs-comment">#用于控制HystrixCommand执行所在线程池的行为</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">coreSize:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#线程池的核心线程数</span><br>    <span class="hljs-attr">maximumSize:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#线程池的最大线程数，超过该线程数的请求会被拒绝</span><br>    <span class="hljs-attr">maxQueueSize:</span> <span class="hljs-number">-1</span> <span class="hljs-comment">#用于设置线程池的最大队列大小，-1采用SynchronousQueue，其他正数采用LinkedBlockingQueue</span><br>    <span class="hljs-attr">queueSizeRejectionThreshold:</span> <span class="hljs-number">5</span> <span class="hljs-comment">#用于设置线程池队列的拒绝阀值，由于LinkedBlockingQueue不能动态改版大小，使用时需要用该参数来控制线程数</span><br><br></code></pre></td></tr></table></figure><h3 id="DashBoard"><a href="#DashBoard" class="headerlink" title="DashBoard"></a>DashBoard</h3><p>Hystrix提供了Hystrix Dashboard来实时监控HystrixCommand方法的执行情况。 Hystrix Dashboard可以有效地反映出每个Hystrix实例的运行情况，帮助我们快速发现系统中的问题，从而采取对应措施。</p><p><img src="https://res.craft.do/user/full/2c016c68-2ea0-5513-42ea-5813d216a654/doc/64F8465D-ECA0-4FC5-8B4D-195A84183BDB/7ED0A8F2-1BE6-4284-B09D-A44390CCE9F6_2" title="image"></p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis</title>
    <link href="/2022/03/28/Spring/Mybatis/"/>
    <url>/2022/03/28/Spring/Mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="Primary-components"><a href="#Primary-components" class="headerlink" title="Primary components"></a>Primary components</h2><ul><li>Configuration<br>  MyBatis所有的配置信息都维持在Configuration对象之中。<strong>包含拦截器的动态代理功能</strong><ul><li><code>SqlSessionFactoryBuilder</code>对象通过该配置生成<code>SqlSessionFactory</code>, <code>SqlSessionFactory.openSession()</code>得到<code>SqlSession</code>对象</li><li>Spring集成版本中, 不再采用Builder生成, 而是SqlSessionFactoryBean的工厂bean方式注入到Spring中</li></ul></li><li>SqlSession<br>作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能。</li><li>MappedStatement<br>MappedStatement是维护了某一条&lt;select|update|delete|insert&gt;节点的封装对象。</li><li>Executor<br>MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护。</li><li>SqlSource           <br>负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回。</li></ul><p><img src="/image/Mybatis/mybatis-y-arch-1.png"></p><ul><li>BoundSql            <br>表示动态生成的SQL语句以及相应的参数信息。</li><li>StatementHandler<br>封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</li><li>ParameterHandler<br>负责对用户传递的参数转换成JDBC Statement 所需要的参数。</li><li>ResultSetHandler <br>负责将JDBC返回的ResultSet结果集对象转换成List类型的集合。</li><li>TypeHandler       <br>负责java数据类型和jdbc数据类型之间的映射和转换。</li><li>DefaultObjectFactory<br>在返回查询结果时, 会调用该类的create方法创建java对象出来, 可以实现该方法自定义新的create方法构造出指定值的对象出来</li></ul><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p><a href="https://pdai.tech/md/framework/orm-mybatis/mybatis-overview.html">Java 全栈知识体系-Mybatis详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Seata</title>
    <link href="/2022/03/28/Spring/Seata/"/>
    <url>/2022/03/28/Spring/Seata/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><ul><li>Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚；</li><li>Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</li><li>Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</li></ul><h3 id="一个典型的分布式事务过程"><a href="#一个典型的分布式事务过程" class="headerlink" title="一个典型的分布式事务过程"></a>一个典型的分布式事务过程</h3><ul><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li><li>XID 在微服务调用链路的上下文中传播；</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ul><p><img src="/image/Seata/seata.png"></p><h3 id="Installation-amp-Use"><a href="#Installation-amp-Use" class="headerlink" title="Installation &amp; Use"></a>Installation &amp; Use</h3><h4 id="1-Seata的配置"><a href="#1-Seata的配置" class="headerlink" title="1. Seata的配置"></a>1. Seata的配置</h4><p>解压seata-server安装包到指定目录，修改<code>conf</code>目录下的<code>file.conf</code>配置文件，主要修改自定义事务组名称，事务日志存储模式为<code>db</code>及数据库连接信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs Objective-C">service &#123;<br>  #vgroup-&gt;rgroup<br>  vgroup_mapping.fsp_tx_group = &quot;default&quot; #修改事务组名称为：fsp_tx_group，和客户端自定义的名称对应<br>  #only support single node<br>  default.grouplist = &quot;127.0.0.1:8091&quot;<br>  #degrade current not support<br>  enableDegrade = false<br>  #disable<br>  disable = false<br>  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent<br>  max.commit.retry.timeout = &quot;-1&quot;<br>  max.rollback.retry.timeout = &quot;-1&quot;<br>&#125;<br><br>## transaction log store<br>store &#123;<br>  ## store mode: file、db<br>  mode = &quot;db&quot; #修改此处将事务信息存储到数据库中<br><br>  ## database store<br>  db &#123;<br>  ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.<br>  datasource = &quot;dbcp&quot;<br>  ## mysql/oracle/h2/oceanbase etc.<br>  db-type = &quot;mysql&quot;<br>  driver-class-name = &quot;com.mysql.jdbc.Driver&quot;<br>  url = &quot;jdbc:mysql://localhost:3306/seat-server&quot; #修改数据库连接地址<br>  user = &quot;root&quot; #修改数据库用户名<br>  password = &quot;root&quot; #修改数据库密码<br>  min-conn = 1<br>  max-conn = 3<br>  global.table = &quot;global_table&quot;<br>  branch.table = &quot;branch_table&quot;<br>  lock-table = &quot;lock_table&quot;<br>  query-limit = 100<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改<code>conf</code>目录下的<code>registry.conf</code>配置文件，指明注册中心为<code>nacos</code>，及修改<code>nacos</code>连接信息即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">registry &#123;<br>  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa<br>  type = &quot;nacos&quot; #改为nacos<br><br>  nacos &#123;<br>  serverAddr = &quot;localhost:8848&quot; #改为nacos的连接地址<br>  namespace = &quot;&quot;<br>  cluster = &quot;default&quot;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>先启动Nacos，再使用seata-server中<code>/bin/seata-server.bat</code>文件启动seata-server。</p><h4 id="2-Java如何集成"><a href="#2-Java如何集成" class="headerlink" title="2. Java如何集成"></a>2. Java如何集成</h4><p>为服务创建一个自定义事务组</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">alibaba:</span><br>    <span class="hljs-attr">seata:</span><br>    <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span> <span class="hljs-comment">#自定义事务组名称需要与seata-server中的对应</span><br><br></code></pre></td></tr></table></figure><p>取消数据源的自动创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeataOrderServiceApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SeataOrderServiceApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建配置使用Seata对数据源做代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用Seata对数据源进行代理</span><br><span class="hljs-comment"> * Created by macro on 2019/11/11.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceProxyConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String mapperLocations;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">druidDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title function_">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceProxy</span>(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">sqlSessionFactoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        sqlSessionFactoryBean.setDataSource(dataSourceProxy);<br>        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>()<br>                .getResources(mapperLocations));<br>        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringManagedTransactionFactory</span>());<br>        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel</title>
    <link href="/2022/03/28/Spring/Sentinel/"/>
    <url>/2022/03/28/Spring/Sentinel/</url>
    
    <content type="html"><![CDATA[<blockquote><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。 Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p></blockquote><h3 id="Caption"><a href="#Caption" class="headerlink" title="Caption"></a>Caption</h3><ul><li>resource：资源名称；</li><li>limitApp：来源应用；</li><li>grade：阈值类型，0表示线程数，1表示QPS；</li><li>count：单机阈值；</li><li>strategy：流控模式，0表示直接，1表示关联，2表示链路；</li><li>controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待；</li><li>clusterMode：是否集群。</li></ul><p>Sentinel具有如下特性:</p><ul><li>丰富的应用场景：承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀，可以实时熔断下游不可用应用；</li><li>完备的实时监控：同时提供实时的监控功能。可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况；</li><li>广泛的开源生态：提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合；</li><li>完善的 SPI 扩展点：提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。</li></ul><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限流功能</span><br><span class="hljs-comment"> * Created by macro on 2019/11/7.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/rateLimit&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitController</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 按资源名称限流，需要指定限流处理逻辑</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@GetMapping(&quot;/byResource&quot;)</span><br>  <span class="hljs-meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;handleException&quot;)</span><br>  <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">byResource</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-string">&quot;按资源名称限流&quot;</span>, <span class="hljs-number">200</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 按URL限流，有默认的限流处理逻辑</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@GetMapping(&quot;/byUrl&quot;)</span><br>  <span class="hljs-meta">@SentinelResource(value = &quot;byUrl&quot;,blockHandler = &quot;handleException&quot;)</span><br>  <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">byUrl</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(<span class="hljs-string">&quot;按url限流&quot;</span>, <span class="hljs-number">200</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> CommonResult <span class="hljs-title function_">handleException</span><span class="hljs-params">(BlockException exception)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResult</span>(exception.getClass().getCanonicalName(),<span class="hljs-number">200</span>);<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Nacos-存储规则"><a href="#Nacos-存储规则" class="headerlink" title="Nacos 存储规则"></a>Nacos 存储规则</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">ds1:</span><br>      <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">dataId:</span> <span class="hljs-string">$&#123;spring.application.name&#125;-sentinel</span><br>      <span class="hljs-attr">groupId:</span> <span class="hljs-string">DEFAULT_GROUP</span><br>      <span class="hljs-attr">data-type:</span> <span class="hljs-string">json</span><br>      <span class="hljs-attr">rule-type:</span> <span class="hljs-string">flow</span><br><br><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/rateLimit/byUrl&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;limitApp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;grade&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;strategy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;controlBehavior&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clusterMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security Oauth</title>
    <link href="/2022/03/28/Spring/Spring%20Security%20Oauth/"/>
    <url>/2022/03/28/Spring/Spring%20Security%20Oauth/</url>
    
    <content type="html"><![CDATA[<p><a href="/2022/03/28/Spring/Spring%20Security/">Spring Security</a> 是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。</p><p>如果要做一个认证登录模块, 那么我们就无法绕过JWT的概念. <strong>JWT</strong> 是将用户登录信息存储在了用户电脑中, 而不再是服务器里. 如果项目中用户量庞大. 并且分为电脑端和移动端. 那么 JWT 是必不可少的.</p><p>但是在企业级项目中，我们更倾向于<a href="/2022/03/28/Distributed%20System/Oauth2/">Oauth2</a>的使用。他保证了我们内部系统的登陆认证，也保证了外部系统的访问控制。</p><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a><strong>授权模式</strong></h2><h3 id="Authorization-Mode"><a href="#Authorization-Mode" class="headerlink" title="Authorization Mode"></a>Authorization Mode</h3><hr><ul><li><strong>Authorization Code</strong><a href="/2022/03/28/Distributed%20System/Oauth2/#授权码">授权码</a>：正宗的OAuth2的授权模式，客户端先将用户导向认证服务器，登录后获取授权码，然后进行授权，最后根据授权码获取访问令牌；</li><li>Implicit (隐式授权模式) ：适用于无应用服务器的项目，和授权码模式相比，取消了获取授权码的过程，直接获取访问令牌；</li><li>**Resource Owner Password Credentials<a href="/2022/03/28/Distributed%20System/Oauth2/#密码式">密码式</a>：客户端直接向用户获取用户名和密码，之后向认证服务器获取访问令牌；</li><li>Client Credentials (客户端模式) ：客户端直接通过客户端认证 (比如client_id和client_secret) 从认证服务器获取访问令牌。</li></ul><h2 id="授权服务配置适配器"><a href="#授权服务配置适配器" class="headerlink" title="授权服务配置适配器"></a><strong>授权服务配置适配器</strong></h2><h3 id="AuthorizationServerConfigurerAdapter"><a href="#AuthorizationServerConfigurerAdapter" class="headerlink" title="AuthorizationServerConfigurerAdapter"></a>AuthorizationServerConfigurerAdapter</h3><hr><ul><li>configure(ClientDetailsServiceConfigurer clients): 配置客户端的授权模式 , 客户端ID , 权限范围 , 权限类型 , token有效期等.</li><li>configure(AuthorizationServerEndpointsConfigurer endpoints): 配置具体的授权模式规则 , 如JWT 密码模式</li></ul><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a><strong>过滤器链</strong></h2><h3 id="WebSecurityConfigurerAdapter-ResourceServerConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter-ResourceServerConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter(ResourceServerConfigurerAdapter)"></a>WebSecurityConfigurerAdapter(ResourceServerConfigurerAdapter)</h3><hr><ul><li>WebSecurityConfigurerAdapter 是 Spring security默认情况下的http配置，而 ResourceServerConfigurerAdapter 是Spring security oauth2 默认情况下的http配置。ResourceServerConfigurerAdapter 的优先级更高一些</li><li><strong>同样的资源地址，只会在优先级最高的 ResourceServerConfigurerAdapter 中生效，如果 WebSecurityConfigurerAdapter 也配置了这个资源地址，则不会生效</strong><ul><li>configure(HttpSecurity httpSecurity)：用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器；</li><li>configure(AuthenticationManagerBuilder auth)：用于配置UserDetailsService及PasswordEncoder；</li><li>RestfulAccessDeniedHandler ：当用户没有访问权限时的处理器，用于返回JSON格式的处理结果</li><li>RestAuthenticationEntryPoint ：当未登录或token失效时，返回JSON格式的结果</li><li>UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现；</li><li>UserDetails：SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要自行实现；</li><li>PasswordEncoder：SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder；</li><li>JwtAuthenticationTokenFilter：在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。</li></ul></li></ul><h2 id="过滤链"><a href="#过滤链" class="headerlink" title="过滤链"></a><strong>过滤链</strong></h2><h3 id="SecurityWebFilterChain"><a href="#SecurityWebFilterChain" class="headerlink" title="SecurityWebFilterChain"></a>SecurityWebFilterChain</h3><hr><ul><li>SpringSecurityFilterChain 作为 SpringSecurity 的核心过滤器链在整个认证授权过程中起着举足轻重的地位，每个请求到来，都会经过该过滤器链</li><li>如果你想自己实现每一个自定义的未授权 , 未认证 , 白名单等策略 , 可以定制该过滤器链</li></ul><h2 id="授权管理器"><a href="#授权管理器" class="headerlink" title="授权管理器"></a><strong>授权管理器</strong></h2><h3 id="ReactiveAuthorizationManager"><a href="#ReactiveAuthorizationManager" class="headerlink" title="ReactiveAuthorizationManager"></a>ReactiveAuthorizationManager</h3><hr><ul><li>WebFlux授权管理器 , 可以当成是拦截器的一种 , 重写方法对授权做自定义处理 , 比如白名单 , 跨域等.</li><li><strong>因为Spring Cloud Gateway使用是基于WebFlux与Netty开发的，所以与传统的Servlet方式不同</strong></li></ul><h2 id="密码式登陆"><a href="#密码式登陆" class="headerlink" title="密码式登陆"></a>密码式登陆</h2><p>Token相关的接口都应该采用Basic base64的请求头，业务相关的接口都应该采用Bearer token的请求头</p><h3 id="认证逻辑"><a href="#认证逻辑" class="headerlink" title="认证逻辑"></a><strong>认证逻辑</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">**# 在实际的开发中，我们不一定需要Basic的方式来对client进行解密验证方式，这只是pig自己的方式。但是的确蛮好用**<br>**# 请求头是Authorization=Basic base64.encode(client_id:client_secret) **<br><br><span class="hljs-comment">// 用户填写账户密码，发送登录请求，后台登录 API 主动发起获取/oauth/token的请求。</span><br><br><span class="hljs-comment">// 我们可以在中间加入网关拦截，验证base64的解密后格式是否正确</span><br>ValidateCodeGatewayFilter.apply()<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 过滤器拦住Basic请求</span><br><span class="hljs-comment">* Spring让他默认拦截/oauth/token</span><br><span class="hljs-comment">*/</span><br>BasicAuthenticationFilter&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 所以再进入BasicAuthenticationFilter过滤器中，将client_id与client_secret解析，变成UsernamePasswordAuthenticationToken对象</span><br>    <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">authRequest</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.authenticationConverter.convert(request);<br>    <br>    <span class="hljs-comment">// 再通过一系列调用去找数据库存的客户端信息和传入的客户端信息比较，如果client_id或client_secret是错的，就报错。</span><br>    <span class="hljs-type">Authentication</span> <span class="hljs-variable">authResult</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.authenticationManager.authenticate(authRequest);<br>    <br>    ProviderManager.authenticate()<br>    →AbstractUserDetailsAuthenticationProvider.authenticate()<br>    →AbstractUserDetailsAuthenticationProvider.retrieveUser()<br>    →DaoAuthenticationProvider.retrieveUser()<br>    →ClientDetailsUserDetailsService.loadUserByUsername()<br>    →配置的PigClientDetailsService.loadClientByClientId()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 专门拦截/oauth/token请求</span><br><span class="hljs-comment">*/</span><br>ClientCredentialsTokenEndpointFilter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAuthenticationProcessingFilter</span>&#123;<br>  <br>  Authentication <span class="hljs-title function_">attemptAuthentication</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 根据clientId和clientSecret最终会去查询client信息</span><br>    <span class="hljs-built_in">this</span>.getAuthenticationManager().authenticate(authRequest);<br>    -&gt; DaoAuthenticationProvider.retrieveUser()<br>    -&gt; ClientDetailsUserDetailsService.loadUserByUsername();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* oauth2.0 token请求接口</span><br><span class="hljs-comment">*/</span><br>TokenEndPoint&#123;<br>  ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title function_">postAccessToken</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 获取client信息，验证请求，授权码和密码式都会进来</span><br>    <br>    <span class="hljs-comment">// 做一些验证操作，内部会开始创建OAuth2AccessToken对象</span><br>    <span class="hljs-type">OAuth2AccessToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<br>    <br>    AbstractTokenGranter&#123;<br>      OAuth2AccessToken <span class="hljs-title function_">grant</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 通过 DefaultTokenServices.createAccessToken() 从tokenStore缓存实现PigCustomTokenServices类中创建OAuth2AccessToken对象，还可以用增强器tokenEnhancer加入附加信息，比如用户对象。</span><br>        <span class="hljs-comment">// 存入缓存，返回对象</span><br>        tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest))<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 一系列操作结束后，返回给请求方token对象</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a><strong>正常访问</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java">**# 请求头需要加入Authorization=Bearer token的模式供服务端验证**<br><br>*<span class="hljs-comment">// 网关不做鉴权拦截，只转发，具体的鉴权操作交由对应的业务微服务处理。只要引入Security依赖，并读取Redis中的Token即可*</span><br><br>*<span class="hljs-comment">// 区别于Auth微服务的AuthorizationServerTokenServices(PigCustomTokenServices)</span><br><span class="hljs-comment">// 我们需要一个通用的ResourceServerTokenServices（PigLocalResourceServerTokenServices）来处理当前业务微服务的令牌认证问题*</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 请求被拦截，开始校验并转换成认证对象，给调用链使用</span><br><span class="hljs-comment">* feign调用也进来这，所以我们需要在feign调用的时候，把请求头带上</span><br><span class="hljs-comment">*/</span><br>OAuth2AuthenticationProcessingFilter&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 从当前线程中抽取请求头的Token值</span><br>    <span class="hljs-comment">// 这一步在feign调用的时候很正常，用于token传递</span><br>    <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> tokenExtractor.extract(request);<br>    <span class="hljs-keyword">if</span> (authentication == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 输出点日志</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 很长的调用，主要是通过token获取认证对象</span><br>      <span class="hljs-type">Authentication</span> <span class="hljs-variable">authResult</span> <span class="hljs-operator">=</span> authenticationManager.authenticate(authentication);<br>      -&gt; OAuth2AuthenticationManager.authenticate(authentication)<br>      -&gt; ResourceServerTokenServices.loadAuthentication(accessToken)<br>      -&gt; PigLocalResourceServerTokenServices(自定义).loadAuthentication(accessToken)<br>      <br>      <span class="hljs-comment">// 存入线程</span><br>      SecurityContextHolder.getContext().setAuthentication(authResult);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 权限拦截器,方法前拦截</span><br><span class="hljs-comment">*/</span><br>FilterSecurityInterceptor <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSecurityInterceptor</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Token续期"><a href="#Token续期" class="headerlink" title="Token续期"></a>Token续期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java">**# 前端可以定时调用/oauth/check_token端点检测Token是否失效过期**<br><br>CheckTokenEndpoint&#123;<br>  checkToken(<span class="hljs-meta">@RequestParam(&quot;token&quot;)</span> String value) &#123;<br>    resourceServerTokenServices.loadAuthentication(token.getValue());<br>  &#125;<br>&#125;<br><br>**# 若即将失效，则刷新令牌/oauth/token?grant_type=refresh_token**<br>**# 如果想要用户请求时对令牌续期，需要在tokenServices#loadAuthentication中进行重写**<br>TokenEndPoint&#123;<br>  ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title function_">postAccessToken</span><span class="hljs-params">()</span>&#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="授权码登陆"><a href="#授权码登陆" class="headerlink" title="授权码登陆"></a>授权码登陆</h2><h3 id="认证逻辑-1"><a href="#认证逻辑-1" class="headerlink" title="认证逻辑"></a><strong>认证逻辑</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Java">**# 如果是内部平台做Oauth2的逻辑，那就先登陆，再跳转到authorize接口**<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 授权码模式专用授权请求</span><br><span class="hljs-comment">* oauth/authorize?</span><br><span class="hljs-comment">* response_type=code&amp;</span><br><span class="hljs-comment">* client_id=CLIENT_ID&amp;</span><br><span class="hljs-comment">* redirect_uri=CALLBACK_URL&amp;</span><br><span class="hljs-comment">* scope=read</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">@SessionAttributes</span><br>AuthorizationEndpoint&#123;<br>  <span class="hljs-comment">// 最终返回confirm页面，供用于确认授权</span><br>  <span class="hljs-comment">// 可以自定义该页面</span><br>  ModelAndView <span class="hljs-title function_">authorize</span><span class="hljs-params">(Principal principal)</span>&#123;<br>    <span class="hljs-comment">// 因为类加入了Session注解，所以将model内容存储在了Session中</span><br>    <span class="hljs-comment">// 后续confirm页面提交时，也会拿到这次的内容</span><br>    <span class="hljs-comment">// 如果redis已经存在该clientId+userName的key，则省略confirm确认，直接返回重定向</span><br>  &#125;<br>&#125;<br><br>**# 如果是第三方调用的话，会在访问authorize接口的时候，因未登录被拦截器重定向到登陆页面，先登陆，然后再返回到authorize接口**<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* confirm页面请求通过，并携带了**user_oauth_approval**参数</span><br><span class="hljs-comment">*/</span><br>AuthorizationEndpoint&#123;<br>  <span class="hljs-comment">// 最终返回重定向地址，并拼接code参数传回</span><br>  View <span class="hljs-title function_">approveOrDeny</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; approvalParameters, Map&lt;String, ?&gt; model, Principal principal)</span>&#123;<br>    <span class="hljs-comment">// 获取从authorize方法存储进session的内容</span><br>    <span class="hljs-comment">// 进行一系列验证后，返回重定向地址+code</span><br>    <span class="hljs-comment">// code默认放进ConcurrentHashMap里面，只要不用，就会一直存在</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 专门拦截/oauth/token请求</span><br><span class="hljs-comment">*/</span><br>ClientCredentialsTokenEndpointFilter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAuthenticationProcessingFilter</span>&#123;<br>  <br>  Authentication <span class="hljs-title function_">attemptAuthentication</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 根据clientId和clientSecret最终会去查询client信息</span><br>    <span class="hljs-built_in">this</span>.getAuthenticationManager().authenticate(authRequest);<br>    -&gt; DaoAuthenticationProvider.retrieveUser()<br>    -&gt; ClientDetailsUserDetailsService.loadUserByUsername(username);<br>    -&gt; ClientDetailsService.loadClientByClientId(username);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* oauth/token?</span><br><span class="hljs-comment">* client_id=CLIENT_ID&amp;</span><br><span class="hljs-comment">* client_secret=CLIENT_SECRET&amp;</span><br><span class="hljs-comment">* grant_type=authorization_code&amp;</span><br><span class="hljs-comment">* code=AUTHORIZATION_CODE&amp;</span><br><span class="hljs-comment">* redirect_uri=CALLBACK_URL</span><br><span class="hljs-comment">*/</span><br>TokenEndPoint&#123;<br><br>  ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title function_">postAccessToken</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">OAuth2AccessToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);<br>    -&gt; AuthorizationServerEndpointsConfigurer.grant()<br>    -&gt; CompositeTokenGranter.grant()<br>    <span class="hljs-comment">// 删除之前的code并返回对应的认证对象，与token值绑定</span><br>    -&gt; AuthorizationCodeTokenGranter.grant().getOAuth2Authentication(client, tokenRequest)<br>    <span class="hljs-comment">// 令牌增强器也在这</span><br>    -&gt; PigCustomTokenServices.createAccessToken(oAuth2Authentication)<br>    <span class="hljs-comment">// 一系列操作结束后，返回给请求方token对象</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正常访问-1"><a href="#正常访问-1" class="headerlink" title="正常访问"></a>正常访问</h3><p>与密码式相同</p><h3 id="Token失效"><a href="#Token失效" class="headerlink" title="Token失效"></a>Token失效</h3><p>与密码式相同</p><hr><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p><a href="/2022/03/28/Distributed%20System/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">SSO单点登录</a></p><p>以Pig项目为例，Auth服务配置了「Spring Security」「Spring Security Oauth2密码模式」「Spring Security Oauth2授权码模式」三种认证方式。</p><p>简单的Spring Security配置是为了在SSO单点登录时与Session结合，让Oauth2授权码模式能够记住登录状态。</p><p>Spring Security Oauth2密码模式是为了给项目内微服务认证使用。</p><hr><h2 id="拓展相关🌟🌟"><a href="#拓展相关🌟🌟" class="headerlink" title="拓展相关🌟🌟"></a>拓展相关🌟🌟</h2><h3 id="BearerTokenExtractor"><a href="#BearerTokenExtractor" class="headerlink" title="BearerTokenExtractor"></a>BearerTokenExtractor</h3><p>该类是通过<code>OAuth2AuthenticationProcessingFilter</code>过滤器默认调用，专门处理用户访问请求，剥离Header中的<code>access_token</code>来确认用户令牌。我们可以实现该类，采用别的名称来替换<code>access_token</code>。比如掘金的就是<code>X-Legacy-Token</code>而非必须是 <code>Authorization</code></p><p>也可以参考pig项目，增加注解AOP实现，对部分接口实现白名单策略，分别解决外部访问以及feign调用的问题。</p><p>Inner注解的使用 <a href="https://www.yuque.com/pig4cloud/pig/hz5ppn">https://www.yuque.com/pig4cloud/pig/hz5ppn</a></p><h3 id="OAuth2FeignRequestInterceptor"><a href="#OAuth2FeignRequestInterceptor" class="headerlink" title="OAuth2FeignRequestInterceptor"></a>OAuth2FeignRequestInterceptor</h3><p>是为了解决Spring服务中Feign调用时，无法将Token通过Header传递给下游服务的问题。</p><p>该类需要程序员实现子类，在Feign调用前从线程中获取authentication对象并传递给父类做内部持有。主要方法是<code>accessTokenContextRelay.copyToken()</code>。</p><p>然后<code>OAuth2FeignRequestInterceptor</code>会根据内部持有的对象对下游服务发起携带Header的请求。下游服务可以从Header中获取Token值，并转换为authentication对象。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Oauth2.0的数据库说明 <a href="https://andaily.com/spring-oauth-server/db_table_description.html">https://andaily.com/spring-oauth-server/db_table_description.html</a></p><p>Spring Oauth流程说明 <a href="https://www.yuque.com/pig4cloud/pig/dqnyuc">https://www.yuque.com/pig4cloud/pig/dqnyuc</a></p><p>分布式系统下的认证与授权 <a href="https://www.bmpi.dev/dev/authentication-and-authorization-in-a-distributed-system/">https://www.bmpi.dev/dev/authentication-and-authorization-in-a-distributed-system/</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shiro</title>
    <link href="/2022/03/28/Spring/Shiro/"/>
    <url>/2022/03/28/Spring/Shiro/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>过滤器简称</th><th>相对应的java类</th></tr></thead><tbody><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter</td></tr><tr><td>logout</td><td>org.apache.shiro.web.filter.authc.LogoutFilter</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter</td></tr></tbody></table><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><hr><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>从**<code>AbstractShiroFilter</code>**<code>#doFilterInternal</code>进入</p><p><code>DefaultSecurityManager #createSubject</code> 负责返回一个Subject</p><p>内部的<code>#resolveSession</code>方法是获取Session信息, 主要走SessionDao方法获取, 可从缓存或数据库读取, 默认走<code>AbstractSessionDao</code>类, 所以从缓存走</p><p>内部的<code>#resolvePrincipals</code>中从Session获取principals信息, 并在**<code>AbstractShiroFilter</code>**类里进行线程绑定</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>Shiro创建Session交由<code>SessionFactory</code>负责, 我们可以实现该类, 创建一个自定义的Session, 比如有用户的一些属性和操作系统浏览器的属性.</p><p>然后在过滤器触发时, 将登录后的用户信息存入到该Session中</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>其实在业务上如果需要Redis来管理Session，那么直接继承**<code>AbstractSessionDao</code>**, 该类有3个实现, 但是只有2个是有用的, 一个是cache存取 , 一个是 ConcurrentHashMap存取</p><ul><li>如果只是在单机环境下需要做Session持久化（服务器重启保持Session在线），那么最好继承<code>EnterpriseCacheSessionDAO</code>来增加本地Session缓存以减少I&#x2F;O开销，否则大量的doReadSession()调用会造成I&#x2F;O甚至网络压力（单机环境下能省一点是一点嘛，集群就没办法省了）；</li><li>如果是在集群环境下做Session共享，千万不要继承EnterpriseCacheSessionDAO，会产生服务器间的本地Session缓存不同步问题，直接继承AbstractSessionDAO即可；</li></ul><h4 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h4><p><strong><code>AbstractShiroFilter</code></strong><code> #doFilterInternal</code>过滤器每一次会触发更新Session的操作<code>updateSessionLastAccessTime</code>, 最终会触发<code>SessionDao.update()</code>, 将更新后的session存入缓存</p><p>Shiro默认会采用定时线程检测session是否失效, 具体可查看定时器类**<code>ExecutorServiceSessionValidationScheduler</code>** 与失效session管理类**<code>AbstractValidatingSessionManager</code>**</p><p>研发人员可实现这两个类, 自己实现相关session失效后的业务逻辑</p><h3 id="认证拦截"><a href="#认证拦截" class="headerlink" title="认证拦截"></a>认证拦截</h3><p>从统一入口**<code>OncePerRequestFilter</code><strong>儿子类</strong><code>AdviceFilter</code>**<code>#doFilterInternal</code>进入, 如果状态为true, 则调用<code>executeChain</code>做后续filter责任链处理, 并可以自定义<code>postHandle</code>方法</p><p>再交由孙子类<code>**PathMatchingFilte**``#preHandle #isFilterChainContinued </code></p><p>接着孙孙子类**<code>AccessControlFilter</code>**<code>#onPreHandle</code> 进行权限认证鉴权</p><p>当访问非anon拦截时, 会交由UserFilter处理认证逻辑, 若认证失败则转到登录页面.</p><p>主要是在<code>filterChainDefinitionMap.put(&quot;/**&quot;, &quot;user,kickout,onlineSession,syncOnlineSession&quot;)</code>配置</p><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><hr><p>当我们访问带有Shiro权限注释的方法时, 会被<code>AnnotationsAuthorizingMethodInterceptor</code>拦截到, 其内部会通过循环对多个权限注释的handler处理类进行鉴权处理, 如果权限不对, 则报错</p><p>多个handler最终还是会交由<code>AuthorizingSecurityManager</code>来做精细化的权限处理.</p><p>而在更内部则会调用**<code>AuthorizingRealm</code>**<code>#getAuthorizationInfo</code>方法, 该方法内部先从Cache获取用户实体, 如果获取不到, 则调用自定义方法从数据库拿</p><h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><p>在鉴权的时候, <strong><code>AuthorizingRealm</code></strong><code>#getAuthorizationInfo</code>会经过缓存</p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ShardingJDBC</title>
    <link href="/2022/03/28/Spring/ShardingJDBC/"/>
    <url>/2022/03/28/Spring/ShardingJDBC/</url>
    
    <content type="html"><![CDATA[<h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a><a href="https://shardingsphere.apache.org/document/current/cn/dev-manual/sharding/">分片算法</a></h3><ul><li>精准分片 StandardShardingStrategy</li><li>范围分片 RangeShardingAlgorithm</li><li>行表达式分片 InlineShardingAlgorithm</li><li>复合分片 ComplexShardingStrategy</li><li>Hint分片 HintShardingStrategy</li><li>不分片 NoneShardingStrategy</li></ul><h3 id="如果SQL中没有分片键，但是代码中有怎么办"><a href="#如果SQL中没有分片键，但是代码中有怎么办" class="headerlink" title="如果SQL中没有分片键，但是代码中有怎么办"></a>如果SQL中没有分片键，但是代码中有怎么办</h3><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>通过解析 SQL 语句提取分片键列与值并进行分片是 Apache ShardingSphere 对 SQL 零侵入的实现方式。若 SQL 语句中没有分片条件，则无法进行分片，需要全路由。</p><p>在一些应用场景中，分片条件并不存在于 SQL，而存在于外部业务逻辑。因此需要提供一种通过外部指定分片结果的方式，在 Apache ShardingSphere 中叫做 Hint。</p><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>Apache ShardingSphere 使用 <code>ThreadLocal</code> 管理分片键值。可以通过编程的方式向 <code>HintManager</code> 中添加分片条件，该分片条件仅在当前线程内生效。</p><p>除了通过编程的方式使用强制分片路由，Apache ShardingSphere 还计划通过 SQL 中的特殊注释的方式引用 Hint，使开发者可以采用更加透明的方式使用该功能。</p><p>指定了强制分片路由的 SQL 将会无视原有的分片逻辑，直接路由至指定的真实数据节点。</p><h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><h4 id="强制分片路由-Hint"><a href="#强制分片路由-Hint" class="headerlink" title="强制分片路由 Hint"></a>强制分片路由 Hint</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HintManager</span> <span class="hljs-variable">hintManager</span> <span class="hljs-operator">=</span> HintManager.getInstance() ;<br>hintManager.setMasterRouteOnly();<br></code></pre></td></tr></table></figure><p>比如戒毒系统，更新后需要立即刷新列表。如果采用了主从复制技术的话，可能读取从库会导致暂时性的缺少数据。</p><p>那么我们就可以在更新的方法中添加该代码，代码下方进行更新和查询操作，那么自然就会去读取主库数据。</p><h4 id="等GTID-方案"><a href="#等GTID-方案" class="headerlink" title="等GTID 方案"></a>等GTID 方案</h4><p>MySQL 提供了一条基于 GTID 的命令，用于在从节点上执行，等待从库同步到了对应的 GTID（binlog文件中会包含 GTID），或者超时返回。</p><p>select wait_for_executed_gtid_set(gtid_set, timeout);</p><p>MySQL 在执行完事务后，会将该事务的 GTID 会给客户端，然后客户端可以使用该命令去要执行读操作的从库中执行，等待该 GTID，等待成功后，再执行读操作；如果等待超时，则去主库执行读操作，或者再换一个从库执行上述流程。</p><p>举个例子，原来要执行读操作的 SQL 和添加了前缀的 SQL 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> city; <span class="hljs-keyword">SET</span> <span class="hljs-variable">@maxscale</span>_secret_variable<span class="hljs-operator">=</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> WAIT_FOR_EXECUTED_GTID_SET(<span class="hljs-string">&#x27;232-1-1&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.ENGINES) <span class="hljs-keyword">END</span>); <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> city;<br></code></pre></td></tr></table></figure><p>当 WAIT_FOR_EXECUTED_GTID_SET 执行失败后，原 SQL 就不会再执行，而是将该 SQL 去主节点执行。</p><h4 id="缓存主库查询次数"><a href="#缓存主库查询次数" class="headerlink" title="缓存主库查询次数"></a>缓存主库查询次数</h4><p>概念很简单, 用户新增或修改后, 往Redis中插入一条数据primaryRead:userid为1, 若多次插入, 则进行累加.</p><p>当用户调用查询接口时, 判断用户的查询缓存次数是否存在, 并减一操作后走主库查询. 若不存在或减一后小于0则走从库查询</p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security</title>
    <link href="/2022/03/28/Spring/Spring%20Security/"/>
    <url>/2022/03/28/Spring/Spring%20Security/</url>
    
    <content type="html"><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Spring Security没有像Shiro一样，创建一个自己掌控的Session出来， 而是默认交由Tomcat处理。虽然Security没有自己创建，但是给了我们可以实现的<code>SessionRegistry</code>，以及用于管理用户和Session的<code>SessionInformation</code></p><p><code>SessionManagementFilter</code>是专门用于管理Session状态的，如检测用户并发Session，失效Session的逻辑处理等</p><ul><li>expiredUrl：是用户并发会话过多，被挤下线后的重定向地址。</li><li>invalidSessionUrl：Session超时的重定向地址</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>spring-session-data-redis依赖, 将Session进行分布式缓存</p><h3 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h3><p>Spring Security采用了事件广播在Session失效时，删除了对应的<code>SessionInformation</code>，我们可以在**<code>SessionRegistryImpl</code>**<code>#onApplicationEvent</code>进行深入的研究</p><h3 id="登陆认证"><a href="#登陆认证" class="headerlink" title="登陆认证"></a>登陆认证</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用户登录后, 交由 AbstractAuthenticationProcessingFilter 过滤器检测是否为登录地址</span><br><span class="hljs-comment">*/</span><br>AbstractAuthenticationProcessingFilter&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-comment">// 判断是否是配置好的验证登录请求</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.requiresAuthentication(request, response)) &#123;<br>      chain.doFilter(request, response);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 尝试身份验证</span><br>      authResult = <span class="hljs-built_in">this</span>.attemptAuthentication(request, response);<br>    &#125;<br>  &#125;<br>  <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 确定后默认再由 UsernamePasswordAuthenticationFilter进行用户获取认证</span><br><span class="hljs-comment">*/</span><br>UsernamePasswordAuthenticationFilter&#123;<br>  Authentication <span class="hljs-title function_">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAuthenticationManager().authenticate(authRequest);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 然后 AbstractUserDetailsAuthenticationProvider#authenticate </span><br>  <span class="hljs-comment">// 会通过username和生成的Authentication对象生成一个UserDetails对象，并检查用户是否存在</span><br>  Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> authentication.getPrincipal() == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;NONE_PROVIDED&quot;</span> : authentication.getName();<br>    <span class="hljs-comment">// 去找缓存, 可以通过ehcache实现该类, 默认是NullUserCache空实现</span><br>    <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userCache.getUserFromCache(username);<br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>      <span class="hljs-comment">// 没有缓存, 则通过DetailService的实现类去数据库查询, 也可以从缓存走</span><br>      user = <span class="hljs-built_in">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication)&#123;<br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">loadedUser</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getUserDetailsService().loadUserByUsername(username);<br>        <span class="hljs-keyword">return</span> loadedUser;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="正常访问"><a href="#正常访问" class="headerlink" title="正常访问"></a>正常访问</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 过滤器链的第二位</span><br><span class="hljs-comment">*/</span><br>SecurityContextPersistenceFilter&#123;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 获取session中的用户信息</span><br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>    <span class="hljs-type">HttpRequestResponseHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequestResponseHolder</span>(request, response);<br>    <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">contextBeforeChainExecution</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.repo.loadContext(holder);<br>    <span class="hljs-comment">// 存入当前线程</span><br>    SecurityContextHolder.setContext(contextBeforeChainExecution);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 异常过滤器</span><br><span class="hljs-comment">*/</span><br>ExceptionTranslationFilter&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 后置过滤器，最终会走到FilterSecurityInterceptor</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      chain.doFilter(request, response);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      <span class="hljs-comment">// 执行exceptionEntrypoint</span><br>      handleSpringSecurityException(request, response, chain, securityException);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 权限拦截器,方法前拦截</span><br><span class="hljs-comment">*/</span><br>FilterSecurityInterceptor <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSecurityInterceptor</span>&#123;<br>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 前置, 检测访问请求是否是白名单，获取线程内认证对象并做权限校验，如@PreAuthorize</span><br>    <span class="hljs-built_in">super</span>.beforeInvocation(filterInvocation);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// </span><br>      filterInvocation.getChain().doFilter(filterInvocation.getRequest(), filterInvocation.getResponse());<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 后置</span><br>      <span class="hljs-built_in">super</span>.finallyInvocation(token);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用户缓存"><a href="#用户缓存" class="headerlink" title="用户缓存"></a>用户缓存</h3><p><code>UserCache</code> 允许配置Ehcache缓存, 用于缓存 <code>UserDetails</code> 对象 , 在  CachingUserDetailsService 类中获取用户实体</p><p>感觉没啥用, 敲了断点发现只有登录的时候能用上该缓存.</p><h2 id="鉴权管理"><a href="#鉴权管理" class="headerlink" title="鉴权管理"></a>鉴权管理</h2><hr><p>spring security的认证与鉴权过滤器都在<code>AbstractSecurityInterceptor</code>拦截器中. 其中鉴权部分交由<code>AbstractAccessDecisionManager</code>实现, 采用了投票机制进行鉴权.默认有三个实现类</p><ul><li><strong>AffirmativeBased(默认)</strong> : 只要任一 AccessDecisionVoter 返回肯定的结果，便授予访问权限</li><li>UnanimousBased : 只要任一 AccessDecisionVoter 返回失败的结果，便全体失败</li><li>ConsensusBased : 少数服从多数授权访问决策方案</li></ul><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs Java">http<br>  <span class="hljs-comment">// 跨域</span><br>  .cors(AbstractHttpConfigurer::disable)<br>  <span class="hljs-comment">// csrf攻击</span><br>  .csrf(AbstractHttpConfigurer::disable)<br>  <span class="hljs-comment">// 完全放开frame页面</span><br>  .headers(h -&gt; h.frameOptions().disable())<br>  <span class="hljs-comment">// 异常处理配置 ExceptionTranslationFilter</span><br>  <span class="hljs-comment">// 在过滤器</span><br>  .exceptionHandling(<br>          <span class="hljs-comment">// 用来解决匿名用户访问无权限资源时的异常</span><br>          e-&gt;e.authenticationEntryPoint(customAuthenticationEntryPoint)<br>          <span class="hljs-comment">// 用来解决认证过的用户访问无权限资源时的异常</span><br>                  .accessDeniedHandler(customAccessDeniedHandler)<br>  <span class="hljs-comment">// session管理器</span><br>  ).sessionManagement(<br>  <span class="hljs-comment">// 同一用户最大允许同时存在几个</span><br>  s-&gt;s.maximumSessions(<span class="hljs-number">10</span>)<br>          <span class="hljs-comment">// 管理所有用户登录的session</span><br>          .sessionRegistry(sessionRegistry())<br>          <span class="hljs-comment">// session失效处理</span><br>          .expiredSessionStrategy(ssoSessionInformationExpiredStrategy)<br>  <span class="hljs-comment">// 认证请求拦截策略, 以下都不拦截处理，但是会走过滤器</span><br>  <span class="hljs-comment">// web.ignore的不拦截处理，是不走过滤器的，一般用于静态资源文件</span><br>).authorizeRequests(<br>  a-&gt; a.antMatchers(<span class="hljs-string">&quot;/sso/*&quot;</span>,<span class="hljs-string">&quot;/logout&quot;</span>)<br>          .permitAll().anyRequest().authenticated()<br>  <span class="hljs-comment">// 登陆失败的处理</span><br>).failureHandler(authenticationFailureHandler())<br>  <span class="hljs-comment">// 退出登陆成功处理</span><br>.logoutSuccessHandler(logoutSuccessHandler())<br>  <span class="hljs-comment">// 登录页面地址</span><br>.formLogin(<br>  f-&gt;f.loginPage(accessTokenUri)<br>        <span class="hljs-comment">// 可以不配置,表示登录提交的地址,用于校验后端登录的url</span><br>        .loginProcessingUrl(<span class="hljs-string">&quot;/login&quot;</span>)<br>          <span class="hljs-comment">// 登录成功后回调</span><br>          .successHandler(customAuthenticationSuccessHandler)<br><span class="hljs-comment">// 在userfilter前执行validateFilter</span><br>).addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)<br><span class="hljs-comment">// 在validateFilter前执行decryptFilter</span><br>.addFilterBefore(decryptParameterFilter, ValidateCodeFilter.class)<br>.apply(ssoAuthenticationSecurityConfig);<br><br><span class="hljs-comment">//禁用session管理</span><br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* ssoAuthenticationSecurityConfig extends SecurityConfigurerAdapter</span><br><span class="hljs-comment">* 可以在CAS中配置业务认证逻辑</span><br><span class="hljs-comment">*/</span><br><br># **基于配置好的路径来进行认证的过滤器 AbstractAuthenticationProcessingFilter**<br><span class="hljs-comment">// 子类实现attemptAuthentication()来做逻辑处理</span><br><span class="hljs-comment">// 交由下面的AuthenticationManager来做认证处理</span><br><br><span class="hljs-comment">// 但是该抽象类中doFilter方法里有this.requiresAuthentication的调用, 里面是AntPathRequestMatcher类</span><br><span class="hljs-comment">// 该类默认记载了/login的url, 表示只有当用户请求地址与之相同时, 才会走下面的认证逻辑, 否则都会交由其他过滤器解决.</span><br><span class="hljs-comment">// 所以我们可以在子类构造中, 重写该地址, 将登陆后的请求地址放进去.*</span><br>AbstractAuthenticationProcessingFilter filter<br><br><span class="hljs-comment">// 用于处理身份验证的核心逻辑, 在CAS中可以根据authentication参数判断有没有被CAS中心认证过</span><br><span class="hljs-comment">// 最终需要返回认证对象</span><br>filter.setAuthenticationManager(providerManager);<br><span class="hljs-comment">// 认证成功后,Security会发布消息,用户可以订阅实现记录成功信息</span><br>providerManager.setAuthenticationEventPublisher();<br><span class="hljs-comment">// 业务模块认证通过后,可以根据savedRequest做跳转之类的</span><br>filter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler)<br></code></pre></td></tr></table></figure><h2 id="JWT无状态"><a href="#JWT无状态" class="headerlink" title="JWT无状态"></a>JWT无状态</h2><p>在认证的过程中，Spring Security会运行一个过滤器<code>SecurityContextPersistenceFilter</code>来存储请求的Security Context，这个上下文的存储是一个策略模式，但默认的是保存在HTTP Session中的<code>HttpSessionSecurityContextRepository</code>。现在我们设置了 create-session&#x3D;”stateless”，就会保存在<code>NullSecurityContextRepository</code>，里面没有任何session在上下文中保持。</p><p>既然没有为何还要调用这个空的filter？因为需要调用这个filter来保证每次请求完了<code>SecurityContextHolder</code>被清空了，下一次请求必须<strong>re-authentication</strong>。</p><h3 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1.</span> 可以继承UsernamePasswordAuthenticationFilter类，去通过UserDetailService获取用户。<br><br><span class="hljs-number">2.</span> 登录校验成功后由配置好的 http.successHandler(JwtLoginSuccessHandler)来返回Token给前端。<br></code></pre></td></tr></table></figure><h3 id="正常访问-1"><a href="#正常访问-1" class="headerlink" title="正常访问"></a>正常访问</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">// 禁用session管理</span><br><span class="hljs-comment">// 跳过 HttpSessionSecurityContextRepository, SessionManagementFilter, RequestCacheFilter. </span><br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br><span class="hljs-comment">// 百度方法一般是继承该类</span><br><span class="hljs-comment">// 也有继承OncePerRequestFilter类的</span><br>JwtAuthorizationFilter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasicAuthenticationFilter</span><br><span class="hljs-comment">// 然后通过配置加入该过滤器</span><br>http.addFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtAuthorizationFilter</span>(authenticationManager()));<br><br></code></pre></td></tr></table></figure><h2 id="认证入口点AuthenticationEntryPoint"><a href="#认证入口点AuthenticationEntryPoint" class="headerlink" title="认证入口点AuthenticationEntryPoint"></a>认证入口点AuthenticationEntryPoint</h2><hr><ul><li>它在用户请求处理过程中遇到认证异常时，被<code>ExceptionTranslationFilter</code>或者<code>AuthenticationFailureHandler</code>用于开启特定认证方案的认证流程。<ul><li><code>Http403ForbiddenEntryPoint</code>: 设置响应状态字为403,并非触发一个真正的认证流程。通常在一个预验证(pre-authenticated authentication)已经得出结论需要拒绝用户请求的情况被用于拒绝用户请求。</li><li><code>HttpStatusEntryPoint</code>: 设置特定的响应状态字，并非触发一个真正的认证流程。</li><li><code>LoginUrlAuthenticationEntryPoint</code>: 根据配置计算出登录页面url,将用户重定向到该登录页面从而开始一个认证流程。</li><li><code>BasicAuthenticationEntryPoint</code>: 对应标准Http Basic认证流程的触发动作，向响应写入状态字401和头部WWW-Authenticate:”Basic realm&#x3D;”xxx”触发标准Http Basic认证流程。</li><li><code>DigestAuthenticationEntryPoint</code>: 对应标准Http Digest认证流程的触发动作，向响应写入状态字401和头部WWW-Authenticate:”Digest realm&#x3D;”xxx”触发标准Http Digest认证流程。</li><li><code>DelegatingAuthenticationEntryPoint</code>: 这是一个代理，将认证任务委托给所代理的多个AuthenticationEntryPoint对象，其中一个被标记为缺省AuthenticationEntryPoint。</li></ul></li></ul><h2 id="用户实体UserDetailService"><a href="#用户实体UserDetailService" class="headerlink" title="用户实体UserDetailService"></a><strong>用户实体UserDetailService</strong></h2><hr><ul><li>Spring Security中进行身份验证的是 AuthenticationManager 接口，ProviderManager 是它的一个默认实现，但它并不用来处理身份认证，而是委托给配置好的 AuthenticationProvider ，每个 AuthenticationProvider 会轮流检查身份认证。检查后或者返回 Authentication 对象或者抛出异常。</li><li>loadUserByUsername：通过用户名获取一个真实用户，返回一个 UserDetails 的实现类</li><li>密码验证由 AuthenticationProvider 的 DaoAuthenticationProvider#additionalAuthenticationChecks 处理，也可以自己定义</li><li>UserDetail目前发现仅在登录时与Authentication做比较操作, 除此以外无他用</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sleuth</title>
    <link href="/2022/03/28/Spring/Zipkin%20Sleuth/"/>
    <url>/2022/03/28/Spring/Zipkin%20Sleuth/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Cloud Sleuth 是分布式系统中跟踪服务间调用的工具，它可以直观地展示出一次请求的调用过程，本文将对其用法进行详细介绍。</p></blockquote><h3 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h3><p>Zipkin是Twitter的一个开源项目，可以用来获取和分析Spring Cloud Sleuth 中产生的请求链路跟踪日志，它提供了Web界面来帮助我们直观地查看请求链路跟踪信息。</p><p>Zipkin是一个单独的服务，Spring项目引入依赖后，再下载Zipkin的jar后启动。</p><p>Zipkin默认记录只是存储在内存中，Zipkin关闭则全部丢失。</p><ul><li>在user-service和ribbon-service中添加相关依赖：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>修改application.yml文件，配置收集日志的zipkin-server访问地址：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">0.1</span> <span class="hljs-comment">#设置Sleuth的抽样收集概率</span><br></code></pre></td></tr></table></figure><h3 id="ElasticSearch存储"><a href="#ElasticSearch存储" class="headerlink" title="ElasticSearch存储"></a>ElasticSearch存储</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-comment"># STORAGE_TYPE：表示存储类型 ES_HOSTS：表示ES的访问地址</span><br>java <span class="hljs-literal">-jar</span> zipkin<span class="hljs-literal">-server-2</span>.<span class="hljs-number">12.9</span><span class="hljs-literal">-exec</span>.jar <span class="hljs-literal">--STORAGE_TYPE</span>=elasticsearch <span class="hljs-literal">--ES_HOSTS</span>=localhost:<span class="hljs-number">9200</span> <br></code></pre></td></tr></table></figure><h3 id="Used-Config"><a href="#Used-Config" class="headerlink" title="Used Config"></a>Used Config</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-number">1</span>、使用rabbitmq+elasticsearch的启动方式<br><br>java -jar zipkin<span class="hljs-selector-class">.jar</span> <span class="hljs-attr">--zipkin</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.addresses</span>=<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span> <span class="hljs-attr">--zipkin</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.username</span>=root <span class="hljs-attr">--zipkin</span><span class="hljs-selector-class">.collector</span><span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.password</span>=<span class="hljs-number">123456</span> <span class="hljs-attr">--zipkin</span><span class="hljs-selector-class">.storage</span><span class="hljs-selector-class">.type</span>=elasticsearch <span class="hljs-attr">--zipkin</span><span class="hljs-selector-class">.storage</span><span class="hljs-selector-class">.elasticsearch</span><span class="hljs-selector-class">.host</span>=http://<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span>:<span class="hljs-number">9200</span> --zipkin.storage.elasticsearch.http-logging=BASIC<br><br><span class="hljs-number">2</span>、使用rabbitmq+mysql启动方式<br><br>java -jar zipkin.jar --zipkin.collector.rabbitmq.addresses=<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span> --zipkin.collector.rabbitmq.username=root --zipkin.collector.rabbitmq.password=<span class="hljs-number">123456</span> --zipkin.storage.type=mysql --zipkin.storage.mysql.host=<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span> --zipkin.storage.mysql.port=<span class="hljs-number">3306</span> --zipkin.storage.mysql.username=root --zipkin.storage.mysql.password=root --zipkin.storage.mysql.db=psych<br><br><span class="hljs-number">3</span>、使用activemq+mysql启动方式<br><br>java -jar zipkin.jar --zipkin.collector.activemq.url=tcp://<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span>:<span class="hljs-number">61616</span> --zipkin.collector.activemq.username=admin --zipkin.collector.activemq.password=admin --zipkin.storage.type=mysql --zipkin.storage.mysql.host=<span class="hljs-number">62.234</span>.<span class="hljs-number">66.186</span> --zipkin.storage.mysql.port=<span class="hljs-number">3306</span> --zipkin.storage.mysql.username=root --zipkin.storage.mysql.password=root --zipkin.storage.mysql.db=psych<br><br><span class="hljs-number">4</span>、使用activemq+elasticsearch方式雷同，只需要将数据源改为elasticsearch即可<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/28/hello-world/"/>
    <url>/2022/03/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MapReduce</title>
    <link href="/2022/03/27/Computer%20Science/MapReduce/"/>
    <url>/2022/03/27/Computer%20Science/MapReduce/</url>
    
    <content type="html"><![CDATA[<p>MapReduce: Simplified Data Processing on Large Clusters</p><span id="more"></span><p><a href="https://www.cnblogs.com/YaoDD/p/6017397.html">原始翻译版本网址：《MapReduce: Simplified Data Processing on Large Cluster 》翻译</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MapReduce 是一种编程模型和一种用来处理和产生大数据集的相关实现。用户定义 map 函数（map function）来处理 key&#x2F;value 键值对来产生一系列的中间的 key&#x2F;value 键值对。还要定义一个 reduce 函数(reduce function)用来合并有着相同中间 key 值的中间 value。许多现实世界中的任务都可以用这种模型来表达，就像下文所展示的那样。</p><p>用这个风格（函数式）编写的程序可以自动并行地在大规模集群上工作。运行时系统会自动处理例如切割输入数据，在机器之间调度程序的执行，处理机器故障以及管理必要的机器间通信等细节问题。这可以让那些对于并行分布式系统<strong>没有任何经验</strong>的程序员也能<strong>很简单</strong>地利用起一个大的分布式系统的资源。</p><p>我们的 MapReduce 的实现运行在一个由大的商业机构成的集群当中并且是高度可扩展的：一个典型的 MapReduce 计算要在上千台机器中处理 TB 数量级的数据。程序员会觉得这个系统非常好用：已经有成千上万的 MapReduce 程序被实现出来并且每天有上千个 MapReduce 任务运行在 Google 的集群上。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在过去五年中，作者和许多 Google 的其他人已经实现了成百上千个用于特殊目的的计算程序用于处理大量的 raw data（如抓取文件，Web 请求日志等），用于计算产生各种各样的 derived data（如倒排索引、Web 文件结构的图片展示、每个 host 抓取的文件数量总结、指定日期最频繁的访问请求等）。许多这种计算程序在概念上都是非常直接的。然而输入的数据量往往很大，并且计算需要分布在成百上千台机器中为了在一个可接受的时间内完成任务。但是除了简单的计算模型以外，我们需要大量复杂的代码用来处理例如如何并行化计算、分发数据、处理故障等等问题。</p><p>为了解决这样的复杂性，我们设计了一种新的抽象，它让我们只需要表示出我们想要执行的计算模型，而将背后复杂的并行化，容错，数据分发，负载平衡等等技术的实现细节隐藏在了库中。我们这种新的抽象是受 Lisp 以及其他一些函数式编程语言中的 map 和 reduce 原语影响而来的。我们意识到为了计算出一系列的中间键值对，许多的计算都需要对于输入中的每个逻辑“记录”进行 map 操作。然后还需要对所有共享同一个 key 的 value 进行 reduce 操作，从而能够对派生的数据进行适当的组合。我们这种让用户自定义 map 和 reduce 操作的编程模型能够让我们简单地对大量数据实现并行化，并且使用重新执行（re-execution）作为主要的容错机制。</p><p>我们这项工作的主要共享是提供了一个简单并且强大的接口能够让我们实现自动的并行化并且分布处理大规模的计算，同时该接口的实现能在大型的商用 PC 集群上获得非常高的性能。</p><p>Section 2 描述了基本的编程模型以及一些简单的例子。Section 3 描述了为我们的基于集群的计算环境量身定做的 MapReduce 接口。Section 4 描述了一些我们认为有用的对于编程模型的改进。Section 5 是对我们的实现在不同任务下的性能测试。Section 6 包含了 MapReduce 在 Google 内的使用情况，包括我们以它为基础重写我们的产品索引系统的经验。Section 7 讨论了相关的工作以及未来的发展。</p><h2 id="Programming-Model"><a href="#Programming-Model" class="headerlink" title="Programming Model"></a>Programming Model</h2><p>计算模型以一系列的键值对作为输入并产生一系列的键值对作为输出。MapReduce 库的用户以“Map”和”Reduce”两个函数来表达计算。</p><p><strong>Map</strong>，是由用户编写的，取一个输入对，并且产生一系列中间的键值对。MapReduce 库将那些具有相同的中间键I的中间值聚集在一起，然后将它们传递给 Reduce 函数。</p><p><strong>Reduce</strong>，同样是由用户编写的，接收一个中间键I和该键对应的一系列的中间值。Reduce 函数通过将这些值合并来组成一个可能更小的集合（值的集合）。通常每个 Reduce 函数只产生 0 个或 1 个输出值。Reduce 函数一般通过一个迭代器（via an iterator）来获取中间值，从而在中间值的数目远远大于内存容量时，我们也能够处理。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面来考虑这样一个问题：统计大量文档中每一个单词出现的次数。对此，用户需要编写类似于如下的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">map</span>(String key, String value):<br>　　　　<span class="hljs-comment">// key: document name</span><br>　　　　<span class="hljs-comment">// value: document contents</span><br>　　　　<span class="hljs-keyword">for</span> each word w in value:<br>　　　　　　EmitIntermediate(w, <span class="hljs-string">&quot;1&quot;</span>);<br><br>　　reduce(String key, Iterator values):<br>　　　　<span class="hljs-comment">// key: a word</span><br>　　　　<span class="hljs-comment">// values: a list of counts</span><br>　　　　<span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>　　　　<span class="hljs-keyword">for</span> each v in values:<br>　　　　　　result += ParseInt(v);<br>　　　　Emit(AsString(result));<br></code></pre></td></tr></table></figure><p>Map 函数为在每一个单词出现的时候，为它加上一个计数（在这个简单的例子中就是加 1）。Reduce 函数对每个单词（作为中间键值对的键）的所有计数进行叠加。</p><p>另外，用户需要用输入输出文件的名字，以及一个可选的 tuning paramete 去 fill in 一个叫 mapreduce specification 的对象。之后，用户调用 MapReduce 函数，将上述定义的对象传递进去。用户的代码将和 MapReduce 库相连（由 C++实现）。Appendix A 中有这个例子所有的代码文档。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">map</span>     (k1,v1)  -&gt;  <span class="hljs-built_in">list</span>(k2,v2)<br>reduce  (k2,<span class="hljs-built_in">list</span>(v2)) -&gt; <span class="hljs-built_in">list</span>(v2)<br></code></pre></td></tr></table></figure><p>需要注意的是，输入的 key 和 value 与输出的 key 和 value 是不同的类型，而中间的 key 和 value 与输出的 key 和 value 是相同的类型（用 k1 和 k2 表示）。我们的 C++实现都是以字符串的形式和用户代码进行交互的，至于将字符串类型转换成相应合适的类型的工作则由用户代码来完成了。</p><h3 id="More-Example"><a href="#More-Example" class="headerlink" title="More Example"></a>More Example</h3><p>接下来是一些能够简单地用 MapReduce 计算模型进行表达的例子</p><p>Distributed Grep（分布式查找）：Map 函数获取匹配提供的模式的行，Reduce 函数只是简单地将这些中间数据拷贝到输出。</p><p>Count of URL Access Frequency（计算 URL 访问频率）：Map 函数处理 web 请求的日志，并且输出。Reduce 函数将拥有相同 URL 的 value 相加，得到对</p><p>Reverse Web-Link Graph：Map 函数输出对，其中 source 所在的 page 都有连向 target 这个 URL 的链接。Reduce 函数将给定 target 的所有的 source URL 连接起来，输出对</p><p>Term-Vector per Host：一个 term vector 表示一系列的键值对，word 表示一篇或者一系列文章中出现的比较重要的单词，frequency 表示它们出现的次数。Map 函数对于每篇输入的文章输出键值对（其中 hostname 是从文章所在的 URL 中抽取出来的）Reduce 函数获取给定 host 的 term vectors。它将这些 term vectors 累加起来，丢弃非频繁出现的 term，并产生一个最终的对。</p><p>Inverted Index：Map 函数对每篇文章进行处理，并输出一系列的对。Reduce 函数接收给定 word 的所有键值对，对相应的 document ID 进行排序并且输出&gt;对。所有输出对的集合构成了一个简单的倒排索引。用了 MapReduce 模型，对单词位置的追踪就变得非常简单了。</p><p>Distributed Sort：Map 函数从每个 record 中抽取出 key，产生键值对。Reduce 函数只是简单地将所有对输出。这个计算模型依赖于 Section 4.1 中描述的划分技巧以及 Section 4.2 中描述的排序特性。</p><p>（上述可以全部理解了）</p><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>对于 MapReduce 的接口，各种各样不同的实现都是可能的。所有正确的选择都是基于当下环境的。比如，一种实现可能适合于小的共享内存的机器，另一种可能适合于大型的 NUMA 多处理器机器，甚至有的是为更大的互联的机器集群设计的。</p><p>本节中描述的实现基于的是 Google 中最常用的计算环境：一个由大量商用 PC 机通过交换以太网互联的集群。在我们的环境中：</p><ol><li>机器通常都是 x86 的双核处理器，其上运行 Linux，每台机器拥有 2-4G 的内存</li><li>商用网络硬件—-通常是 100 M&#x2F;s 或者 1 G&#x2F;s，但是综合起来要小于平均带宽</li><li>一个集群由成千上万台机器组成，因此机器故障是常有的事</li><li>存储由便宜的 IDE 磁盘提供，它们都与独立的机器直接相连。一个内部研发的文件系统用于管理所有存储于这些硬盘上的文件。该文件系统通过 Replication 在不可靠的硬件上提供了可用性和可靠性</li><li>用户提交 jobs 给调度系统。每个 job 由一系列的 task 组成，并且由调度器分配到集群中一系列可用的机器上</li></ol><h3 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h3><p>通过将输入数据自动分割成 M 份，Map 函数得以在多台机器上分布式执行。每一个输入块都能并行地在不同的机器上执行。通过划分函数(例如，hash(key) mod R)将中间键划分为 R 份，Reduce 函数也能被分布式地调用。其中划分的数目 R 和划分函数都是由用户指定的。</p><p><img src="/image/MapReduce/OS_3_1-20220327162940686.png" alt="OS_3_1"></p><p>上图 1 展示了在我们的实现中 MapReduce 全部的流程。当用户程序调用 MapReduce 函数时，接下来的动作将按序发生（图 1 中标记的数字与下面的数字是一一对应的）：</p><ol><li>用户程序中的 MapReduce 库首先将输入文件划分为M片，每片大小一般在 16MB 到 64MB 之间（由用户通过一个可选的参数指定）。之后，它在集群的很多台机器上都启动了相同的程序拷贝。</li><li>其中有一个拷贝程序是特别的——master。剩下的都是 worker，它们接收 master 分配的任务。其中有 M 个 Map 任务和 R 个 Reduce 任务要分配。master 挑选一个空闲的 worker 并且给它分配一个 map 任务或者 reduce 任务。</li><li>被分配到 Map 任务的 worker 会去读取相应的输入块的内容。它从输入文件中解析出键值对并且将每个键值对传送给用户定义的 Map 函数。而由 Map 函数产生的中间键值对缓存在内存中。</li><li>被缓存的键值对会阶段性地写回本地磁盘，并且被划分函数分割成 R 份。这些缓存对在磁盘上的位置会被回传给 master，master 再负责将这些位置转发给 Reduce worker。</li><li>当 Reduce worker 从 master 那里接收到这些位置信息时，它会使用远程过程调用从 Map worker 的本地磁盘中获取缓存的数据。当 Reduce worker 读入全部的中间数据之后，它会根据中间键对它们进行排序，这样所有具有相同键的键值对就都聚集在一起了。排序是必须的，因为会有许多不同的键被映射到同一个 reduce task 中。如果中间数据的数量太大，以至于不能够装入内存的话，还需要另外的排序。</li><li>Reduce worker 遍历已经排完序的中间数据。每当遇到一个新的中间键，它会将 key 和相应的中间值传递给用户定义的 Reduce 函数。Reduce 函数的输出会被添加到这个 Reduce 部分的输出文件中。</li><li>当所有的 Map tasks 和 Reduce tasks 都已经完成的时候，master 将唤醒用户程序。到此为止，用户代码中的 MapReduce 调用返回。</li></ol><p>当成功执行完之后，MapReduce 的执行结果被存放在 R 个输出文件中（每个 Reduce task 对应一个，文件名由用户指定）。通常用户并不需要将 R 个输出文件归并成一个。因为它们通常将这些文件作为另一个 MapReduce 调用的输入，或者将它们用于另外一个能够以多个文件作为输入的分布式应用。</p><p>（个人理解：module R 将中间键值对分为 R 份一方面是为了执行 Reduce work 的处理器进行分布式并行计算，另一方面，产生的分布式数据也可以接着用于其他能以多文件为输入的分布式应用。）</p><h3 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h3><p>在 master 中保存了许多的数据结构。对于每个 Map task 和 Reduce task，master 都保存了它们的状态（idle，in-progress 或者是 completed）以及 worker 所在机器的标识（对于非 idle 空转状态的 tasks 而言）。</p><p>master 相当于是一个管道，通过它 Map task 所产生的中间文件被传递给了 Reduce task。因此，对于每一个已经完成的 Map task，master 会存储由它产生的 R 个中间文件的位置和大小（分配给 R 个 Reduce task 执行，需要远程读取这些数据，所以要记录位置和大小）。当 Map task 完成的时候，master 就会收到位置和大小的更新信息。而这些信息接下来就会逐渐被推送到处于 in-progress 状态的 Reduce task 中。</p><h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><p>容错处理</p><p>因为 MapReduce 库的设计初衷是用成千上万的机器去处理大量的数据，所以它就必须能用优雅的方式对机器故障进行处理。</p><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>master 会周期性地 ping 每一个 worker。如果经过了一个特定的时间还未从某一个 worker 上获得响应，那么 master 会将 worker 标记为 failed。所有由该 worker 完成的 Map task 都被回退为 idle 状态，因此能够被重新调度到其他的 worker 上。同样的，所有 failed worker 正在执行的 Map task 或者 Reduce task 也会被回退为 idle 状态，并且被重新调度。</p><p><strong>发生故障的机器上已经完成的 Map task 需要重新执行的原因是，它们的输入是保存在本地磁盘的，因此发生故障之后就不能获取了。而已经完成的 Reduce task 并不需要被重新执行，因为它们的输出是存放在全局的文件系统中的。</strong></p><p>当一个 Map task 开始由 worker A 执行，后来又由 worker B 执行（因为 A 故障了）。所有执行 Reduce task 的 worker 都会收到这个重新执行的通知。那些还未从 worker A 中读取数据的 Reduce task 将会从 worker B 中读取数据。</p><p>MapReduce 对于大面积的机器故障是非常具有弹性的。例如，在一次 MapReduce 操作中，网络维护造成了集群中八十台机器在几分钟的时间内处于不可达的状态。MapReduce 的 master 只是简单地将不可达的 worker 机器上的工作重新执行了一遍，接着再继续往下执行，最终完成了 MapReduce 的操作。</p><h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><p>对于 master，我们可以简单地对上文所述的 master 数据结构做周期性的快照。如果一个 master task 死了，我们可以很快地根据最新的快照来重新启动一个 master task。但是，因为我们只有一个 master，因此故障的概率比较低。所以，在我们的实现中如果 master 出现了故障就只是简单地停止 MapReduce 操作。用户可以检测到这种情况，并且如果他们需要的话可以重新开始一次 MapReduce 操作。</p><h4 id="Semantics-in-the-Presence-of-Failures"><a href="#Semantics-in-the-Presence-of-Failures" class="headerlink" title="Semantics in the Presence of Failures"></a>Semantics in the Presence of Failures</h4><p>如果用户提供的 Map 和 Reduce 操作是关于输入值的确定性函数，那么我们分布式的实现将会产生同样的输出，在整个程序经过没有出现故障的顺序执行之后。</p><p>我们依赖 Map task 和 Reduce task 原子性地提交输出来实现上述特性。每一个正在执行的 task 都会将它的输出写到一个私有的临时文件中。一个 Reduce task 产生一个这样的文件，而一个 Map task 产生 R 个这样的文件（每个 Reduce work 一个）。当一个 Map task 完成的时候，worker 就会给 master 发送一个信息，，其中包含了 R 个临时文件的名字。如果 master 收到了一个来自于已经完成了的 Map task 的完成信息，那么它就将它自动忽略。否则，将 R 个文件的名称记录到一个 master 数据结构中。</p><p>当一个 Reduce task 完成的时候，Reduce worker 会自动将临时输出文件命名为最终输出文件。如果同一个 Reduce task 在多台机器上运行，那么多个重命名操作产生的最终输出文件名将会产生冲突。对此，我们依赖底层文件系统提供的原子重命名操作来保证最终文件系统中的数据来自一个 Reduce task。</p><p>大多数的 Map 和 Reduce 操作都是确定性的，事实上，我们的语义等同于顺序执行。因此这让程序员非常容易地能够解释他们程序的行为。当 Map 和 Reduce 操作是非确定性的时候，我们提供较弱，但仍然合理的语义。在非确定性的操作中，对于一个特定的 Reduce task $R_1$ 的输出是对应非确定性程序顺序执行产生的一个结果。然而，对于另一个 Reduce task $R_2$，它的输出对应于非确定性程序另一个顺序执行的结果。</p><p>下面考虑 Map task $M$和 Reduce task $R_1$和$R_2$。让$e(R_i)$表示$R_i$的执行结果。更弱的语义意味着，$e(R_1)$可能从 M 的一次执行结果中读取输入，而$e(R_2)$可能从 M 的另一次执行中读取输入。</p><h3 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h3><p>网络带宽在我们的计算环境中是相对稀缺的资源。我们通过将输入数据（由 GFS 管理）存储在集群中每台机器的本地磁盘的方法来节省带宽。GFS 将输入文件切分成 64MB 大小的块，并且将每个块的多份拷贝（通常为 3 份）存储在不同的机器上。MapReduce 的 master 获取所有输入文件的位置信息，然后将 Map task 调度到有相应输入文件副本的机器上。当发生故障时，再将 Map task 调度到邻近的具有该 task 输入文件副本的机器（即在同一台交换机内具有相同数据的机器）。当在一个集群的大量机器上做 MapReduce 操作时，大多数的输入数据都是从本地读取的，而不用消耗带宽。</p><h3 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h3><p>如上所述，我们将 Map 操作分成 M 份，Reduce 操作分成 R 份。在理想的情况下，M 和 R 的值应该要比集群中 worker machine 的数量多得多。让一个 worker 同时进行许多不同的 task 有利于提高动态的负载均衡，同时在一个 worker 故障的时候能尽快恢复。许多已经完成的 Map task 也能尽快地传播到其他所有的 worker machine 上。</p><p>在我们的实现中，M 和 R 的大小是有一个实用范围的。因为我们的 master 需要做$O(M+R)$个调度决定，并且还要在内存中保存$O(M * R)$个状态（源自前面所说：<strong>对于每一个已经完成的 Map task，master 会存储由它产生的 R 个中间文件的位置和大小。</strong>）。（但是内存使用的常数还是比较小的，$O(M*R)$个 Map task&#x2F;Reduce task 状态对，每个的大小大概在一个字节）</p><p>另外，R通常受限于用户，因为每个 Reduce task 的输出都分散在不同的输出文件中。事实上，我们会选择M，使得每个输入文件大概 16MB 到 64MB 的输入文件（因此上文所述的局部性优化会达到最优，减少带宽负担，尽量利用本地存储数据进行 Map task）。而我们会让 R 成为 worker machine 数量的一个较小的倍数。因此，我们通常在进行 MapReduce 操作时，$M&#x3D;200000，R&#x3D;5000$，使用 2000 个 worker machine。</p><h3 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h3><p>“straggler”（落伍的士兵）的存在是拖慢整个 MapReduce 操作的通常的原因之一。所谓的”straggler”是指一台机器用了过长的时间去完成整个计算任务中最后几个 Map task 或者 Reduce task。Straggler 出现的原因有很多。比如一台机器上硬盘坏了，它就会经历大量的可纠正错误，从而让它的性能从 30MB&#x2F;s 下降到 1MB&#x2F;s。集群的调度系统可能将其他 task 调度到该机器上，导致它执行 MapReduce 代码的速度变慢很多，因为 CPU，内存，本地磁盘，网络带宽的竞争加剧。我们最近遇到的一个问题是一台机器的初始化代码有点问题，它会导致处理器的缓存被禁用，在这些受影响的机器上进行的计算速度会下降到原来的百分之一。（ping 得到不判定为故障机，但是自身速度过慢会拖累整体，出现短板效应）</p><p>对此，我们有一个通用的机制用来缓解 straggler 的问题。当 MapReduce 操作接近结束的时候，master 会将那些仍在执行的 task 的备份进行调度执行。无论是原来的还是备份执行完成，该 task 都将被标记为已完成。我们通过调整将该操作导致的计算资源消耗仅仅提高了几个百分点（只在即将结束的时候进行备份竞争执行）。但是在完成大型的 MapReduce 操作时，却让整个执行时间下降了好多。例如，Section 5.3 中所描述的排序算法在备份机制关闭的情况下，需要多消耗 44%的时间。</p><h2 id="Refinements"><a href="#Refinements" class="headerlink" title="Refinements"></a>Refinements</h2><p>虽然对于大多数需求由 Map 和 Reduce 函数提供的功能已经足够了，但是我们还是发现了一些有用的扩展。对它们的描述如下。</p><h3 id="Partitioning-Function"><a href="#Partitioning-Function" class="headerlink" title="Partitioning Function"></a>Partitioning Function</h3><p>MapReduce 用户决定他们的 Reduce task 或者输出文件的数目 R。通过一个划分函数，根据中间键值将各个 task 的数据进行划分。默认的划分函数是通过哈希（比如，hash(key) mod R）。这通常会产生非常好的较为均衡的划分。但是在其他一些情况下，通过键值的其他函数来划分要更好一些。例如，有的时候输出键值是一些 URL，我们希望同一个 host 的内容能放在同一个输出文件中。为了支持这种情况，MapReduce 库的用户可以提供一个特殊的划分函数。例如，使用“hash(Hostname(urlKey)) mod R”作为划分函数，从而让所有来自于同一个 host 的 URL 的内容都输出到同一个输出文件。</p><p>（个人理解，hash 之前可以根据需求（key 的相似性、urlhost 相同）对 key 提前进行一次分组）</p><h3 id="Ordering-Guarantees"><a href="#Ordering-Guarantees" class="headerlink" title="Ordering Guarantees"></a>Ordering Guarantees</h3><p>我们确保在一个给定的划分中，中间键值对都按照键值的升序进行处理。这样的处理顺序确保了每一个划分产生一个排好序的输出文件。这样的话，如果输出文件格式需要支持根据 key 进行有效的随机查找会比较方便。同时，输出文件（应用）的用户也会觉得已经排好序的数据使用起来特别方便。</p><h3 id="Combiner-Function"><a href="#Combiner-Function" class="headerlink" title="Combiner Function"></a>Combiner Function</h3><p>在有些情况下，每个 Map task 都会产生大量的中间键的重复而用户指定的 Reduce 函数是交互和关联的。Section 2.1 中的单词统计就是一个很好的例子。因为单词的出现频率服从于 Zipf 分布，每个 Map Task 都会产生成百上千个这样的记录。所有这些记录都会通过网络被送到一个 Reduce task 中，并且由 Reduce 函数加在一起去产生一个数。我们允许用户使用了可选的 Cominer 函数，用于在网络传输之前部分地进行归并操作。</p><p>Combiner 函数在每个执行 Map task 的机器上执行。通常 Combiner 和 Reduce 函数使用的是相同的代码。Reduce 函数和 Combiner 函数<strong>唯一的不同</strong>是 MapReduce 库<strong>如何处理函数的输出</strong>。Reduce 函数的输出写到最终的输出文件中。而 Combiner 函数的输出会被写到一个最终将被送给 Reduce task 的中间文件中（合并后替代原有的中间键值对集合传递给 Reduce Task 机器，这样减少了带宽的占用）。</p><p>部分的合并操作能极大地加速某类特定的 MapReduce 操作。Appendix A 包含了一个使用 Combiner 的例子。</p><h3 id="Input-and-Output-Types"><a href="#Input-and-Output-Types" class="headerlink" title="Input and Output Types"></a>Input and Output Types</h3><p>MapReduce 库提供了对读入数据文件多种的格式支持。例如，”text”格式的输入将每一行作为键值对：key 是文件内的偏移，value 是该行的内容。另外一种比较常用的格式存储一系列按照键进行排序的键值对。每一个输出格式的实现都知道如何将自己进行合理的划分从而能让不同的 Map task 进行处理（例如，text 模式就知道将区域划分到以行为边界）。用户可以通过简单地定义一个 reader 接口来提供一个新的输入类型的实现。事实上，大多数用户只使用了预定义输入类型的很小一部分。</p><p>reader 并不一定要从文件中读取数据。例如，我们可以很容易地定义一个从数据库，或者内存中映射的数据结构中读取记录的 reader。</p><p>同理，我们也支持产生不同格式的输出数据，用户也能编写新的输出数据格式。</p><h3 id="Side-effects"><a href="#Side-effects" class="headerlink" title="Side-effects"></a>Side-effects</h3><p>在有些情况下，MapReduce 的用户会很容易发现 Map 或者 Reduce 操作会产生一些辅助文件作为额外的输出文件。我们依赖应用的编写者去保证这些副作用是原子和幂等的。一般来说，应用会写到一个临时文件中，并且在它完全产生之后，通过一个原子操作将它重命名。</p><p>对于一个单一的 task 产生的多个输出文件，我们不提供原子性的两相提交支持。因此，产生多个输出文件并且有跨文件一致性要求的 task 需要是确定性的。但是这样的限制在实践过程中并不是什么问题。</p><h3 id="Skipping-Bad-Records"><a href="#Skipping-Bad-Records" class="headerlink" title="Skipping Bad Records"></a>Skipping Bad Records</h3><p>有时候，如果用户的代码中有 bug 的话，会导致 Map 或者 Reduce 操作在某些记录上崩溃。这些 bug 会导致 MapReduce 操作的正常完成。对于这种情况，通常就是去修 bug。不过有时候这是不可行的，也许 bug 是第三方库造成的，而我们并不能得到它的源代码。而且，有时候我们允许忽略掉一些记录，例如在对一个大数据集做分析的时候。因此我们提供了一种可选的执行模式，当 MapReduce 库检测到一些记录会造成崩溃时，就会主动跳过它们，从而保证正常地运行。</p><p>每一个 worker 进程都安装了一个 signal handler 用于捕捉段错误和 bug。在调用用户的 Map 和 Reduce 操作之前，MapReduce 库会将参数的序号保存在一个全局变量中。如果用户代码产生了一个信号，signal handler 就会传输一个参数含有序号的”last gasp”UDP 包给 MapReduce 的 master。当 master 在一个特定的记录中发现了不知一次的错误，这表示在下一次执行相应的 Map 或者 Reduce 操作的时候一个将它跳过。</p><h3 id="Local-Execution"><a href="#Local-Execution" class="headerlink" title="Local Execution"></a>Local Execution</h3><p>Map 或者 Reduce 函数的调试问题是非常 tricky 的。因为实际的计算发生在分布式的系统中，通常由成百上千台机器组成，并且工作的分配由 master 动态执行。为了帮助调试，分析，以及小规模的测试，我们开发了另外一个 MapReduce 库的实现，它能够在本地机器上顺序执行一个 MapReduce 操作的所有工作。它的控制交给用户，因此计算可以被限定到制定的 Map task 中执行。用户利用指定的 flag 启动程序，然后就能非常简单地使用任何它们觉得有用的调试或者测试工具了。</p><h3 id="Status-Information"><a href="#Status-Information" class="headerlink" title="Status Information"></a>Status Information</h3><p>master 运行了一个内置的 HTTP server 并且输出了一系列供人们使用的状态页。状态页会显示程序的计算过程，例如已经完成了多少个 task，还有多少个 task 正在执行，输入的字节数，中间数据的字节数，输出的字节数，以及处理速度等等。该页还包含了指向各个 task 的标准错误和标准输出链接。用户可以利用这些数据来判断计算会持续多长时间，以及计算是否需要添加更多的资源。这些页面还能用来发现什么时候处理速度比预期地下降好多。</p><p>另外，顶层的状态页显示了那些 worker 出错了，以及在它们出错时正在执行哪些 Map 和 Reduce task。这些信息在诊断用户代码出现的 bug 时是非常有用的。</p><p>MapReduce 库提供了一个叫 counter 的设施用于统计各种不同事件出现的次数。例如，用户可能想要统计已经处理过的单词的数目或者德国文件的索引数量。</p><p>为了使用这一特性，用户代码创建一个命名的 counter 对象，并且在 Map 以及 Reduce 函数中对 counter 进行增加。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Counter* uppercase;<br>uppercase = GetCounter(<span class="hljs-string">&quot;uppercase&quot;</span>);<br><br><span class="hljs-built_in">map</span>(String name, String contents):<br>　　<span class="hljs-keyword">for</span> each word w in contents:<br>　　　　<span class="hljs-keyword">if</span>(IsCapitalized(w)):<br>　　　　　　uppercase-&gt;Increment();<br>　　　　EmitIntermediate(w, <span class="hljs-string">&quot;1&quot;</span>);<br></code></pre></td></tr></table></figure><p>每个 worker 机器上 counter 的值会定期传给 master（捎带在给 master 的 ping 回复中）。master 将来自成功执行的 Map 和 Reduce task 的 counter 值聚集起来。然后在 MapReduce 操作完成之后返回给用户代码。当前的 counter 值也会显示在 master 的状态页上（前述的 state pages），所以用户能从实时观看计算的进行。在聚集 counter 的值的时候，master 会消除 Map 或者 Reduce task 的重复执行造成的重复计算。（重复执行可能由 backup tasks 或者因为错误重新执行的 task 引起）。</p><p>有些 counter 的值是由 MapReduce 库自动维护的，例如已经处理的输入键值对数目以及已经产生的输出键值对数目。</p><p>用户发现 counter 特性对于检查 MapReduce 操作的执行是非常有用的。例如，在有些 MapReduce 操作中，用户代码想要确保产生的输出对的数目和已经处理的输入对的数目是恰好相等的（比如检查满射），或者处理的德语文件的数目占总处理文件数目的比重在一个可容忍的范围内。</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>在这个 section 中，我们通过运行在一个集群上的两个 computation 来测试 MapReduce 的性能。一个 Computation 搜索一个 T 的数据，从中获取一个特定的模式。另一个 computation 对一个 T 的数据进行排序。</p><p>这两个程序代表了由用户实际编写的 MapReduce 程序的一个子集———一类程序用于将数据从一种表示方法切换到另一种表示方法。另一类程序则从大数据集中抽取出一小部分有趣的数据。</p><h3 id="Cluster-Configuration"><a href="#Cluster-Configuration" class="headerlink" title="Cluster Configuration"></a>Cluster Configuration</h3><p>所有程序都运行在一个由 1800 台机器组成的机器上。每一台机器都有两个 2GHz 的 Intel Xeon 处理器，并且允许 Hper-Threading（超线程）， 4GB 内存，两个 160GB 的 IDE 磁盘，以及一个 G 比特的以太网链路。这些机器被安排在一个两层树状的交换网络中，根节点的带宽大概在 100-200Gbps。因为所有机器都在同一个托管设备中，因此任意两台机器间的 RTT 少于 1ms。</p><p>其中 4GB 中的 1-1.5G 是为集群中运行的其他任务预留的。程序在一个周末的下午运行，此时 CPU，磁盘，网络基本都处于空闲状态。</p><h3 id="Grep"><a href="#Grep" class="headerlink" title="Grep"></a>Grep</h3><p>grep 程序需要扫描 10 的十次方条 100-byte 的记录，搜索一个相对罕见的三字符模式（出现了 92337 次）。输入被分成大概 64MB 份（M &#x3D; 15000），所有的输出文件都存放在一个文件中（R &#x3D; 1）。</p><p>Figure 2 显示了 Computation 随着时间的变化过程。Y 轴代表了输入数据的扫描速度。随着机器逐渐加入 MapReduce 的计算当中，速度越来越快，当有 1764 个 worker 加入时，达到峰值 30GB&#x2F;s。随着 Map task 的结束，速度开始下降并且在 80s 的时候到达 0,。整个 Computation 从开始到结束总共花费了大概 150s。这其中还包括了 1 分钟的启动开销。开销主要来源于将程序分发到 worker machine 中，和 GFS 交互并打开 1000 个输入文件，以及获取局部性优化所需的信息的延时。</p><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><p>排序程序用于对 10 的十次方条记录（大概 1T 的数据）进行排序。程序以 TeraSort benchmark 为模型。</p><p>排序程序由不超过 50 行用户代码组成，一个三行的 Map function 从 text 的一行中提取一个 10-byte 的排序 key，与原始的 text line 组合成一个中间 key&#x2F;value pair。我们使用内置的 Identity 函数作为 Reduce 的运算符。这一函数将中间键值对传递出作为输出对。最终的排序输出是一个二路复制的 GFS 文件。</p><p>输入被分成 64MB 份（M &#x3D; 15000），而将输出分为 4000 份（R &#x3D; 4000）。分割成许根据初始的 key 将其分割到 R 份中的一个。</p><p><img src="/image/MapReduce/OS_3_2-20220327170521059.png" alt="OS_3_2"></p><p>图 3（a）展示了排序程序的正常执行，左上方的图表示读入的速率，在达到峰值 13GB&#x2F;s 后迅速滑落因为所有的 map tasks 在 200 秒内就已经完成。值得注意的是，输入的速率慢于 grep 操作（对于相同的 M 划分），这是因为对于 sort 操作，花费了一半的事件以及 I&#x2F;O 带宽用于将中间键值对结果写入本地磁盘，而 grep 操作对应的输出则可以小到忽略不计。</p><p>中间左边的图表示经历 map tasks 后通过网络向 reduce tasks 传输数据的速率。这一混排在首个完成的 map task 后启动。第一个突起表示所有 reduce tasks 运行的第一个批次（R &#x3D; 1700 nearly all），开始计算后 300 秒左右，第一批次的部分 reduce tasks 完成，我们开始向完成的机器进一步递送剩余 reduce tasks 的数据。</p><p>左下的图表示排序好的数据向最终文件写出的速率。从第一批次 reduce tasks 完成到开始写数据有一段时间间隔，这是因为机器忙于对中间数据进行排序。</p><p>关于速度的比较，输入数据高于 shuffle 速率和输出速率，这是因为输入是基于本地存储，而又因为网络带宽的限制，以及输出要求两份 replica 的要求，shuffle 速率高于输出速率。我们写成两个副本，因为这是我们的底层文件系统提供的可靠性和可用性机制要求。 如果底层文件系统使用擦除编码（erasure coding）而不是复制（replication），则可以减少写入数据的网络带宽要求。</p><p>（GFS 介绍的论文里应该会解释为什么需要两份 replica）。</p><h3 id="Effect-of-Backup-Tasks"><a href="#Effect-of-Backup-Tasks" class="headerlink" title="Effect of Backup Tasks"></a>Effect of Backup Tasks</h3><p>在图 3（b）中，我们展示了禁止 backup tasks 情况下执行排序操作的结果。流程与图 3（a）很相似，但存在一个相当长的且看不出有明显活动的尾部。960 秒后，除了剩余的 5 个，其余 reduce tasks 均已完成，然而剩余的 stragglers 直到 300 秒后才完成任务，着导致整体耗时 1283 秒，比具备 backup tasks（最终备份处理任务）情况下多耗时 44%。</p><h3 id="Machine-Failures"><a href="#Machine-Failures" class="headerlink" title="Machine Failures"></a>Machine Failures</h3><p>在图 3（c）中，我们展示了将 1746 台工作机器中的 200 台机器故意宕机几分钟以模拟机器故障情况下排序操作的执行结果，底层的集群立刻重启新的工作进程（因为仅仅是 kill 进程，实际上机器功能良好）。</p><p>worker 的 deaths 通过图表中负值输入速率来表示，因为先前一些已完成的 map work 丢失而需要被重新执行（根据先前分析，由于 map task 得到的中间结果存储在本地，宕机后无法正确访问，使得之前的任务需要被重新执行 re-execute）。重执行开始得十分迅速，整体耗时仅仅比正常情况多耗时 5%。</p><h2 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h2><p>我们得 MapReduce 库首个版本于 2003 年 2 月写成，并在 2003 年 8 月进行了重要加强，包括引入局部优化，worker 执行任务间动态负载均衡等等。从那时起，我们非常欣喜得看到 MapReduce 在解决各类问题上的广泛应用。现在，它已 Google 用于以下广泛领域的研究。</p><ul><li>大规模机器学习问题</li><li>Google News 和 Froogle products（Google 购物）的聚类问题</li><li>提取用于生成热门查询报告的数据（如 Google Zeitgeiest）</li><li>提取网页上进行的试验或产品性能</li><li>大规模图形计算</li></ul><h2 id="Large-Scale-Indexing"><a href="#Large-Scale-Indexing" class="headerlink" title="Large-Scale Indexing"></a>Large-Scale Indexing</h2><p>目前为止，我们最重要的 MapReduce 应用之一是重写一个产生谷歌搜索引擎需要的数据结构的复杂系统。索引系统以被抓取系统检索到的文件（GFS 文件形式储存）为输入，raw content 大小约 20T，索引进程进行约 10 次 MapReduce 组成的序列操作。相较于先前 ad-hoc 分布式索引系统，现在应用 MapReduce 后，系统具备以下优点：</p><ul><li>因为与容错、分布式、并行化相关内容隐藏在库重，索引代码更加简单、精巧、易于理解。比如，计算的一个阶段从原有 3800 行 C++代码削减至 700 行。</li><li>概念上可与计算分开，从而使改动变得简单。</li><li>内部对一些机器故障的解决使得整个过程更容易成功执行。进一步的，也更容易向系统中加入新的机器。</li></ul><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>现在 MapReduce 已成功被 Google 应用于各种目的，我们将这种成功归功于以下原因。</p><ul><li>甚至对于并行和分布式系统缺乏相关经验的编程人员，由于相关细节隐藏在库中，模型仍具备易用性。</li><li>大量问题易于以 MapReduce 地方式解决。</li><li>我们将其实现在大规模集群上，因而适于很多大型问题。</li></ul><p>在这项工作中我们学习到很多，</p><ul><li>重新定义编程范式使得并行&#x2F;分布式运算易于实现，也获得了相当的容错性能。</li><li>网络带宽作为稀缺资源，使得我们的很多优化都意在减少通过网络传输的数据。</li><li>冗余的任务执行（backup tasks）可以用于减少缓慢机器的影响，以及解决机器故障和数据丢失。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo多端同步</title>
    <link href="/2022/03/26/git/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/03/26/git/hexo%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这是一篇关于Hexo博客框架如何在git中多端同步的学习记录</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">git init  //初始化本地仓库<br>git remote add origin git@github.com:yourname/yourname.github.io.git  //将本地与Github项目对接<br>git checkout -b hexo  //新建并切换到hexo分支上<br>git add . //将必要的文件依次添加<br>git commit -m <span class="hljs-string">&quot;Blog Source Hexo&quot;</span><br>git push origin hexo  //push到Github项目的hexo分支上<br></code></pre></td></tr></table></figure><h3 id="图片同步"><a href="#图片同步" class="headerlink" title="图片同步"></a>图片同步</h3><p>当我想要在博客与Typora软件中都想要看到文章内引用的本地图片时，发生了渲染错误。博客的服务器端不支持Typora的本地路径引用方式。</p><p>为此我查看了一下Hexo的文档，发现官方默认指定了图片存放路径 <code>source/image</code> 下。</p><p>既然官方要求了，那我便只好更改Typora插入图片时的相关规则</p><ol><li><p>Typora -&gt; 偏好设置 -&gt; 图像 -&gt; 插入图片时 (复制到指定路径) <code>~/hexo/blog/source/image/$&#123;filename&#125;</code> 并勾选下方的所有子项</p></li><li><p>格式 -&gt; 图像 -&gt; 设置图片根目录 -&gt; 选中 <code>~/hexo/blog/source</code> 路径，这一步是保证了博客与Typora都能预览到图片内容</p><p>这一步等同于在文章头部添加 <code>typora-root-url: ../../</code> 配置项，注意要选到blog文件夹中</p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>学习时在最终的 <code>git push origin hero</code>命令中遇到了 <font color='red'>Permission denied</font> 相关问题，发现需要生成新的ssh key，来添加给git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&#x27;github注册时的邮箱&#x27;</span><br><span class="hljs-comment"># 一路回车，最后会在～/.ssh目录中生成密钥文件</span><br><span class="hljs-comment"># 将id_rsa.pub公钥添加到git中</span><br><span class="hljs-comment"># 再执行 git push origin hexo 即可</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
